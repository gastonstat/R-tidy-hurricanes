[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tidy Hurricanes",
    "section": "",
    "text": "About\n\n\n\n\n\n\n\n\n\nThe goal of this text is to help you get started working with tabular data using the syntactic approach of so-called Tidyverse tools. More specifically, we describe various examples for how to use functions from Tidyverse packages to perform common operations around data tables by analyzing storms and hurricanes in the North Atlantic.\n\nAbout You\nI am assuming that you have both R or RStudio installed in your computer. If this is not the case, you can take a look at Breaking the Ice with R\nhttps://www.gastonsanchez.com/R-ice-breaker\n\n\nCitation\nYou can cite this work as:\nSanchez, G. (2023) Analyzing Tropical Storms with Tidyverse Tools.  https://www.gastonsanchez.com/R-tidy-hurricanes\n\n\n\nMy Series of R Tutorials\nThis manuscript is part of a series of texts that I’ve written about Programming and Data Analysis in R:\n\nBreaking the Ice with R: Getting Started with R and RStudio  https://www.gastonsanchez.com/R-ice-breaker\nTidy Hurricanes: Analyzing Tropical Storms with Tidyverse Tools  https://www.gastonsanchez.com/R-tidy-hurricanes\nR Coding Basics: An Introduction to the Basics of Coding in R  https://www.gastonsanchez.com/R-coding-basics\nRolling Dice: Exploring Simulations in Games of Chance with R  https://www.gastonsanchez.com/R-rolling-dice\nWeb Technologies in R: A Short Introduction to Web Technologies in R  https://www.gastonsanchez.com/R-web-technologies\n\n\n\n\nDonation\nAs a Data Science and Statistics educator, I love to share the work I do. Each month I spend dozens of hours curating learning materials like this resource. If you find any value and usefulness in it, please consider making a one-time donation—via paypal—in any amount (e.g. the amount you would spend inviting me a cup of coffee or any other drink). Your support really matters.\n\n\n\nLicense\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License."
  },
  {
    "objectID": "1-01-introduction.html",
    "href": "1-01-introduction.html",
    "title": "1  Tables and Tidyverse",
    "section": "",
    "text": "Hey, what if my data is not in tabular format?\n\nWhile it is true that not all data sets are stored or organized in tables, in most data analysis projects—sooner or later—you will be handling data in some sort of rectangular structure. Because of this, I firmly believe that the best way to get you started learning about data analysis with R is by getting your hands dirty manipulating tables.\nObviously there are limitations. Not everything that is done in data analysis can be done with tables. But having a solid foundation around data arranged in this format will pay off down your data analysis road.\n\nInstalling Tidyverse\nSince this text focuses on Tidyverse tools, you will need to install the associated ecosystem of Tidyverse packages. This is very easy to do.\nRecall that there are a couple of different ways to install R packages. One common option is to invoke the install.packages() function in R’s console, specifying the name(s) of the package(s), within quotations, and separated by commas, to be installed. Like this:\n# run the command below in the console\n# (don't include this command in any Rmd or qmd file)\n# don't worry too much if you get a warning message\ninstall.packages(\"tidyverse\")\nAnother option to install a package in RStudio is to do it by using the Packages tab located in the pane that contains other tabs such as Files, Plots, Help, etc. In the Packages tab you can find the “Install” button, click it, and follow the steps to install \"tidyverse\".\nRemember that you only need to install a package once! After a package has been installed in your machine, there is no need to call install.packages() again on the same package. What you should always invoke, in order to use the functions in a package, is the library() function:\n\n# you should include this command in your source file(s)\nlibrary(tidyverse)\n\nAbout loading packages: Another rule to keep in mind is to always load any required packages at the very top of your script files (e.g. .R or .Rmd or .qmd or .Rnw files). Avoid calling the library() function in the middle of a script. Instead, load all the packages before anything else.\n\n\nA bit about Tidyverse\nTidyverse is not a single package. Instead, it is a collection of packages. This means that when you install \"tidyverse\", you are actually installing the following packages\n\n\"ggplot2\": for creating plots and graphics\n\"dplyr\": for manipulating tables\n\"tidyr\": to tidying-up your data\n\"readr\": for importing rectangular data\n\"tibble\": provides “improved” R data frames\n\"stringr\": for string manipulation\n\"forcats\": for working with R factors\n\"purrr\": for functional programming in R\n\nTo learn more about other tidyverse details, visit:\nhttps://tidyverse.tidyverse.org/\n\n\nNote\nWe won’t cover all the functionality provided by Tidyverse. Instead, we will focus on \"dplyr\" and \"ggplot2\"."
  },
  {
    "objectID": "1-02-about-hurricanes.html",
    "href": "1-02-about-hurricanes.html",
    "title": "2  Tropical Storms and Hurricanes",
    "section": "",
    "text": "NASA satellite image of hurricane Sandy, 2012 (source: wikimedia commons)\nSource: https://en.wikipedia.org/wiki/Hurricane_Sandy"
  },
  {
    "objectID": "1-02-about-hurricanes.html#a-little-bit-about-hurricanes",
    "href": "1-02-about-hurricanes.html#a-little-bit-about-hurricanes",
    "title": "2  Tropical Storms and Hurricanes",
    "section": "2.1 A little bit about Hurricanes",
    "text": "2.1 A little bit about Hurricanes\nI don’t remember very well when was the first time I got interested in Hurricanes. I did not grow up in hurricane country or anywhere near regions prone to be hit by this kind of storms. However, I do remember learning about clouds, meteorology, and how storms form over mountain ranges. I learned this when I was in my early 20s taking my first steps into the mountaineering world. Experiencing the force and dangers of several storms in the mountains and volcanoes of my homeland, sparked in me a general interest to know more about this type of weather phenomena.\nIt is said that the word hurricane is derived from the Spanish word huracán which in turn comes from the Taino word hurakán, that was used by the indigenous people of the Caribbean and Central America to designate the “god of wind” or the “evil spirits of the wind”. Nowadays, the word hurricane is informally used to denote low-pressure systems with organized thunderstorm activity that form over tropical or subtropical waters. Among weather experts, though, the term hurricane is reserved for a specific class of tropical systems: those that reach wind speeds of at least 74 mph, and are exclusively formed over the Atlantic Ocean or eastern Pacific Ocean.\nDespite my longtime interest in storms and hurricanes, my level of expertise in these subjects is fairly limited. Because of this, I prefer to give you a curated list of some facts about hurricanes that I’ve collected from the following sources:\n\nNational Oceanic and Atmospheric Administration (NOAA): https://www.noaa.gov/education/resource-collections/weather-atmosphere/hurricanes\nSciJinks: It’s all about weather! https://scijinks.gov/hurricane/\nNASA Space Place: How Do Hurricanes Form? https://spaceplace.nasa.gov/hurricanes/en/\n\n\n2.1.1 Tropical Cyclones\n\nHurricanes are the most powerful and violent storms on Earth.\nThey form near the equator over warm ocean waters.\nThe scientific term for all these storms is tropical cyclone.\nA tropical cyclone is a rotating low-pressure weather system that produces strong winds, has organized thunderstorms, and comes with heavy rainfall.\nIf it hits land, it typically creates storm surge flooding, tornadoes, and rip currents.\nPeople call these storms by other names, such as typhoons or cyclones, depending on where they occur.\nOnly tropical cyclones that form over the Atlantic Ocean or eastern Pacific Ocean are called “hurricanes.”\n\n\n\n\n\n\nNomenclature of tropical cyclones around the world.\n\n\n\n\n\n\n2.1.2 Storm Classification\n\nTropical cyclones are classified by their maximum wind speed:\n\nWinds less than 39 mph: Tropical depressions\nWinds 39-73 mph: Tropical storms\nWinds 74 mph or greater: Hurricanes\n\nScientifically speaking, Hurricanes are tropical cyclones whose sustained winds have reached 74 mph.\nAt this point the hurricane reaches category 1 on the Saffir-Simpson Hurricane Wind Scale.\nThe Saffir-Simpson Hurricane Wind Scale is a 1 to 5 rating based on a hurricane’s sustained wind speed:\n\ncategory 1: 74-95 mph; 64-82 kt; 119-153 km/h\ncategory 2: 96-110 mph; 83-95 kt; 154-177 km/h\ncategory 3: 111-129 mph; 96-112 kt; 178-208 km/h\ncategory 4: 130-156 mph; 113-136 kt; 209-251 km/h\ncategory 5: 157 mph or higher; 137 kt or higher; 252 km/h or higher\n\nMajor hurricanes are defined as Category 3, 4, and 5 storms.\nThe scale was created by wind engineer Herb Saffir and meteorologist Bob Simpson to help explain damage that buildings will sustain under different wind speeds.\nNote that the Saffir-Simpson scale does not include hazards from rain, flooding, or storm surge.\n\n\n\n2.1.3 Naming Storms\n\nOnce a system escalates to tropical storm-level winds (39 mph or more), it is given a name.\nThe names are chosen by an international committee of the World Meteorological Organization (WMO).\nThe list of names is available at: https://www.nhc.noaa.gov/aboutnames.shtml\nThe Atlantic Ocean hurricane-naming system has been around since 1953.\nFor the first twenty-five or so years, hurricanes and tropical storms were exclusively given female names.\nIn 1979, the names began alternating between masculine and feminine.\nThe names proceed in alphabetical order, omitting the “difficult” letters Q, U, X, Y, and Z.\nNames are reused every six years, although the WMO may retire the name of a particularly deadly or costly storm.\nIn the event that more than 21 named tropical cyclones occur in the Atlantic basin in a season, or more than 24 named tropical cyclones in the eastern North Pacific basin, any additional storms will take names from an alternate list of names approved by the WMO for each basin.\n\n\n\n2.1.4 Atlantic Hurricane Season\n\nThe official Atlantic hurricane season runs from June through November, but occasionally storms form outside those months.\nSeptember is the most active month (where most of the hurricanes occur), followed by August, and October (based on 1851 to 2015 data).\nA typical year has 12 named storms, including six hurricanes of which three become major hurricanes (category 3, 4, and 5).\nNo hurricanes made U.S. landfall before June and after November during the period studied (1851 to 2015 data).\n\n\n\n2.1.5 Storm Formation\nTo close this chapter, take a look at the following diagram that beautifully describes and illustrates the formation of hurricanes.\nSource: https://scijinks.gov/hurricane/\n\n\n\n\n\nHow do hurricanes form? (source: SciJinks)\n\n\n\n\nIf you want to know more about the formation of hurricanes, you can also watch the following video by NOAA SciJinks:\nhttps://www.youtube.com/embed/wPDoIrGUrEc"
  },
  {
    "objectID": "1-03-storms-data.html",
    "href": "1-03-storms-data.html",
    "title": "3  Data Set storms",
    "section": "",
    "text": "In order to have a gentle introduction, we are going to use the data set storms that comes in one of the most popular tidyverse packages: \"dplyr\". This package contains a large number of functions that allow us to manipulate tables in a substantially consistent and user-friendly way. We will also start with some of the graphing functions from the package \"ggplot2\" to produce simple visualizations."
  },
  {
    "objectID": "1-03-storms-data.html#atlantic-hurricane-data",
    "href": "1-03-storms-data.html#atlantic-hurricane-data",
    "title": "3  Data Set storms",
    "section": "3.1 Atlantic Hurricane Data",
    "text": "3.1 Atlantic Hurricane Data\nThe aforementioned data set storms is a curated table from the so-called Hurricane Databases (HURDAT), which is a collection of databases managed by the National Hurricane Center (NHC).\n\nHURDAT involves two databases: one for storms occurring in the Atlantic Ocean, and another one for storms occurring in the Eastern Pacific Ocean.\nHURDAT contains records from year 1851 till present.\nKeep in mind that in the past (before 1970s?), tropical depressions, that did not develop into tropical storms or hurricanes were not included within the database.\n\nAn interesting note from Wikipedia: around 1963, NASA’s Apollo space program requested data, on the climatological impacts of tropical cyclones on launches of space vehicles at the Kennedy Space Center. The basic data was taken from the National Weather Records North Atlantic Tropical to include data from 1886–1968. As a result of this work, a requirement for a computerized tropical cyclone database at the National Hurricane Center (NHC) was realized.\nhttps://en.wikipedia.org/wiki/HURDAT\n\n3.1.1 Data storms\nThe package \"dplyr\" contains a dataset called storms which is a subset of the NOAA Atlantic hurricane database best track data. This database is one of several data sets available in the National Hurricane Center (NHC) Data Archive, which is part of the National Oceanic and Atmospheric Administration (NOAA). In case you are curious about the specifications and format of this type of data, you can visit the following link:\nhttp://www.nhc.noaa.gov/data/#hurdat\nThe data storms includes the positions and attributes of tropical systems in the North Atlantic. If you are using a version of \"dplyr\" greater than or equal to 1.0.10, the storms are from the period 1975 to 2020, measured every six hours during the lifetime of a storm.\nAssuming that you’ve loaded \"tidyverse\" (or \"dplyr\") in R, when you type the name of the data object, you would get something like this:\n\nstorms\n\n# A tibble: 19,066 × 13\n   name   year month   day  hour   lat  long status      category  wind pressure\n   <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <fct>          <dbl> <int>    <int>\n 1 Amy    1975     6    27     0  27.5 -79   tropical d…       NA    25     1013\n 2 Amy    1975     6    27     6  28.5 -79   tropical d…       NA    25     1013\n 3 Amy    1975     6    27    12  29.5 -79   tropical d…       NA    25     1013\n 4 Amy    1975     6    27    18  30.5 -79   tropical d…       NA    25     1013\n 5 Amy    1975     6    28     0  31.5 -78.8 tropical d…       NA    25     1012\n 6 Amy    1975     6    28     6  32.4 -78.7 tropical d…       NA    25     1012\n 7 Amy    1975     6    28    12  33.3 -78   tropical d…       NA    25     1011\n 8 Amy    1975     6    28    18  34   -77   tropical d…       NA    30     1006\n 9 Amy    1975     6    29     0  34.4 -75.8 tropical s…       NA    35     1004\n10 Amy    1975     6    29     6  34   -74.8 tropical s…       NA    40     1002\n# ℹ 19,056 more rows\n# ℹ 2 more variables: tropicalstorm_force_diameter <int>,\n#   hurricane_force_diameter <int>\n\n\nLet’s describe what’s going on in the above output.\n\nAs you can tell, storms is a tibble object, which is one of the data objects in R that handles data in tabular format.\ntibbles are not a native R object; instead they are a modern version of data frames, and their related functions come from the homonym package \"tibble\".\n\nThe way tibbles are printed or displayed is very interesting.\n\nthe number of rows that are displayed is limited to 10;\ndepending on the width of the printing space, you will only see a few columns shown to fit such width,\nunderneath the name of each column there is a three letter abbreviation inside angle brackets,\nthis abbreviation indicates the data type used by R to store the values:\n\n<chr> stands for character data\n<dbl> means double (i.e. real numbers or numbers with decimal digits)\n<int> means integer (numbers with no decimal digits)\n<ord> indicates an ordinal factor which is how R handles categorical data\n<log> indicates logical or boolean values (e.g. true and false)\n\nnotice that the last three lines indicate the number of additional rows as well as the number of additional columns and their names.\n\n\n\n3.1.2 storms Documentation\nYou can find a more technical description of storms by taking a peek at its manual (or help) documentation. All you need to do is run this command:\n\n?storms\n\nHere’s a full description of all the columns:\n\nname: Storm name\nyear, month, and day: Date of report\nhour: Hour of report (in UTC)\nlat: Latitude\nlong: Longitude\nstatus: Storm classification (Tropical Depression, Tropical Storm, or Hurricane)\ncategory: Saffir-Simpson storm category (estimated from wind speed. -1 = Tropical Depression, 0 = Tropical Storm)\nwind: storm’s maximum sustained wind speed (in knots)\npressure: Air pressure at the storm’s center (in millibars)\nts_diameter: Diameter of the area experiencing tropical storm strength winds (34 knots or above)\nhu_diameter: Diameter of the area experiencing hurricane strength winds (64 knots or above)\n\nYou can take a look at the manual (or help) documentation to confirm the description of the variables in data storms.\n\nSome Remarks\n\nThe data table storms is already in R; later you will learn how to import tables in R\nThe table is already clean, there’s no need to fix weird values, or transform from one data type to another.\nNot only the table is clean, but it is also tidy which is the technical term to indicate that:\n\nevery column is a variable.\nevery row is an observation.\nevery cell is a single value."
  },
  {
    "objectID": "1-03-storms-data.html#general-inspection",
    "href": "1-03-storms-data.html#general-inspection",
    "title": "3  Data Set storms",
    "section": "3.2 General Inspection",
    "text": "3.2 General Inspection\nWhen dealing with a data table, especially for the first time, I like to do a quick inspection of the general structure of the data, meaning the number of rows and columns, the name and data-type of each column, and some times also to quickly inspect a few rows either at the top or at the bottom of the table. To do all these things there is a handful of functions:\n\nstr(): to get a summary of the table’s structure\ndim(): to get the dimensions (number of rows and columns)\nnrow(): to get just the number of rows\nncol(): to get just the number of columns\nnames(): to get the column names; there’s also colnames()\nhead(): to look at a few first rows\ntail(): to look at a few last rows\n\nFor instance, to get a general summary of the table’s structure, we can use str() and its argument vec.len = 1 to simplify the amount of output:\n\nstr(storms, vec.len = 1)\n\ntibble [19,066 × 13] (S3: tbl_df/tbl/data.frame)\n $ name                        : chr [1:19066] \"Amy\" ...\n $ year                        : num [1:19066] 1975 ...\n $ month                       : num [1:19066] 6 6 ...\n $ day                         : int [1:19066] 27 27 ...\n $ hour                        : num [1:19066] 0 6 ...\n $ lat                         : num [1:19066] 27.5 28.5 ...\n $ long                        : num [1:19066] -79 -79 ...\n $ status                      : Factor w/ 9 levels \"disturbance\",..: 7 7 ...\n $ category                    : num [1:19066] NA NA ...\n $ wind                        : int [1:19066] 25 25 ...\n $ pressure                    : int [1:19066] 1013 1013 ...\n $ tropicalstorm_force_diameter: int [1:19066] NA NA ...\n $ hurricane_force_diameter    : int [1:19066] NA NA ...\n\n\nLikewise, to explore the dimensions, that is the number of rows and columns, you can invoke dim():\n\ndim(storms)\n\n[1] 19066    13\n\n\nAlternatively, you can also call nrow() or ncol() if you prefer to get just the number of rows or just the number of columns:\n\nnrow(storms)\n\n[1] 19066\n\nncol(storms)\n\n[1] 13\n\n\nOften, I like to use head() and/or tail() to see the first and/or the last rows of a table. In this way I can get an idea of what the data looks like without having to print all the entries.\n\ntail(storms)\n\n# A tibble: 6 × 13\n  name   year month   day  hour   lat  long status       category  wind pressure\n  <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <fct>           <dbl> <int>    <int>\n1 Wanda  2021    11     6    18  37.1 -38   tropical st…       NA    35     1002\n2 Wanda  2021    11     7     0  37.4 -37.4 tropical st…       NA    35     1003\n3 Wanda  2021    11     7     6  38.1 -36.4 tropical st…       NA    35     1004\n4 Wanda  2021    11     7    12  39.2 -34.9 other low          NA    35     1006\n5 Wanda  2021    11     7    18  40.9 -32.8 other low          NA    40     1006\n6 Wanda  2021    11     8     0  43.2 -29.7 other low          NA    40     1006\n# ℹ 2 more variables: tropicalstorm_force_diameter <int>,\n#   hurricane_force_diameter <int>"
  },
  {
    "objectID": "2-01-intro-ggplot.html",
    "href": "2-01-intro-ggplot.html",
    "title": "4  Graphics with \"ggplot2\"",
    "section": "",
    "text": "As previously said, our main focus will be around what I consider to be the two primary data exploration tools from tidyverse: the packages \"dplyr\" and \"ggplot2\". The overarching approach of tidyverse is its focus on long-form data and fast intuitively named functions, which has become immensely popular.\nBefore we get our hands dirty analyzing the storms data set, as well as other external data sets, I want to give you a crash introduction to some of the fundamental ideas behind tidyverse. Likewise, I want to quickly review a handful of functions. The idea is to have a stepping stone that we can use to further explore the fascinating data of storms."
  },
  {
    "objectID": "2-01-intro-ggplot.html#sample-data",
    "href": "2-01-intro-ggplot.html#sample-data",
    "title": "4  Graphics with \"ggplot2\"",
    "section": "4.1 Sample Data",
    "text": "4.1 Sample Data\nFor illustration purposes, I would like to begin with a small data set. To be more specific, let’s consider data for a set of tropical cyclones that formed during the month of September 2010 in the North Atlantic. If you ask me why I’m choosing this particular set of storms, here are three random fun facts: 1) September tends to be the most active month for the formation of tropical cyclones in the North Atlantic; 2) 2010 was the year I moved to the USA, and 3) Sep-2010 turned out to have a storm named Gaston 😉.\n\n\n\n\n\n\n\n\n# A tibble: 8 × 5\n  name     wind pressure category  days\n  <chr>   <dbl>    <dbl> <chr>    <int>\n1 Gaston     35     1005 ts           1\n2 Hermine    60      989 ts           4\n3 Igor      135      924 cat4        13\n4 Julia     120      948 cat4         8\n5 Karl      110      956 cat3         4\n6 Lisa       75      982 cat1         6\n7 Matthew    50      998 ts           3\n8 Nicole     40      994 ts           1\n\n\nAs you can tell, the data is in tabular format organized into five columns and eight rows. Each row corresponds to a single storm, in turn, the columns are:\n\nname is the name given to the storm,\nwind corresponds to the maximum wind speed (in knots) reached by the storm,\npressure has to do with the minimum pressure (in millibars) reached by the storm,\ncategory indicates the category:\n\nts stands for tropical storm\ncat1 is a category-1 hurricane\ncat3 is a category-3 hurricane\ncat4 is a category-4 hurricane\n\ndays gives the duration of the storm in number of days\n\nThe way this data is handled in R is with a tibble object. This class of object provides the rectangular structure to store tables in tidyverse, and it is central to this ecosystem.\nRecall that tibbles are printed in a very peculiar form:\n\nthe number of rows that are displayed is limited to 10;\ndepending on the width of the printing space, you will only see a few columns shown to fit such width,\nunderneath the name of each column there is a three letter abbreviation inside angle brackets,\nthis abbreviation indicates the data type used by R to store the values:\n\n<chr> stands for character data\n<dbl> means double (i.e. real numbers or numbers with decimal digits)\n<int> indicates integer\n\n\nHere’s the command I’ve used to create this tibble:\n\nsep2010 <- tibble(\n  name = c('Gaston', 'Hermine', 'Igor', 'Julia', 'Karl', 'Lisa', 'Matthew', 'Nicole'),\n  wind = c(35, 60, 135, 120, 110, 75, 50, 40),\n  pressure = c(1005, 989, 924, 948, 956, 982, 998, 994),\n  category = c('ts', 'ts', 'cat4', 'cat4', 'cat3', 'cat1', 'ts', 'ts'),\n  days = c(1L, 4L, 13L, 8L, 4L, 6L, 3L, 1L)\n)\n\nTo create a tibble you use the tibble() function. One option to organize the content is by passing individual vectors (one vector per column) separated by commas."
  },
  {
    "objectID": "2-01-intro-ggplot.html#basics-of-ggplot2",
    "href": "2-01-intro-ggplot.html#basics-of-ggplot2",
    "title": "4  Graphics with \"ggplot2\"",
    "section": "4.2 Basics of \"ggplot2\"",
    "text": "4.2 Basics of \"ggplot2\"\nWith the sep2010 data, we may be interested in obtaining a graphic to visualize the association between wind and pressure, like the following scatter plot:\n\n\n\n\n\n\n\n\n\n\n4.2.1 Some Terminology\nBefore I show you how to produce the above scatter plot, it’s important to introduce some of the key terminology used in \"ggplot2\":\n\nThe starting point is the data that we want to visualize. The convention is to have data in a table object (e.g. data.frame, tibble) in which variables are stored as columns.\nThen we have so-called geoms, short for geometric objects; these are basically things such as bars, lines, points, polygons, and other kind of marks that are drawn to represent the data.\nGeoms have visual properties, formally known as aesthetic attributes, and colloquially referred to as aesthetics; these are things such as \\(x\\) and \\(y\\) positions, line color, fill color, point shapes, etc.\nThe use of a variable to encode a visual property of a geom is called a mapping.\nScales are used to handle the mapping from the values in the data space to values in the aesthetic space.\nGuides are those auxiliary elements that allow the viewer to decode the mapping of the visual properties back to the data space. Perhaps the most typical guides are the tick marks, the labels on an axis, and legends (when applicable).\n\nAt its core, graphing data can be reduced to mapping (or associating) data values to visual properties of geometric objects. The data values tend to be expressed in numerical or categorical scales, while the visual properties include the \\(x\\) and \\(y\\) positions of points, colors of lines, height of bars, and so on.\nAt a glance, mapping a number with an \\(x\\) coordinate may seem very different from mapping a number with a color of a point, but at the conceptual level, these two seemingly different mappings are equivalent.\nIn the grammar of graphics, this deep similarity is not just recognized, but made central."
  },
  {
    "objectID": "2-01-intro-ggplot.html#basic-scatterplot",
    "href": "2-01-intro-ggplot.html#basic-scatterplot",
    "title": "4  Graphics with \"ggplot2\"",
    "section": "4.3 Basic Scatterplot",
    "text": "4.3 Basic Scatterplot\nA basic ggplot() specification looks like this:\n\nggplot(data = sep2010, aes(x = wind, y = pressure))\n\nThis creates a ggplot object using the data frame sep2010. It also specifies default aesthetic mappings within aes():\n\nx = wind maps the column wind to the \\(x\\) position\ny = pressure maps the column pressure to the \\(y\\) position\n\n\"ggplot2\" has a simple requirement for data structures: they must be stored in data frames or tibbles, and each type of variable that is mapped to an aesthetic must be stored in its own column.\nAfter we’ve given ggplot() the data frame and the aesthetic mappings, there’s one more critical component. We need to tell it what geometric objects to put there. At this point, \"ggplot2\" doesn’t know if we want bars, lines, points, or something else to be drawn on the graph.\nWe’ll add geom_point() to draw points, resulting in a scatter plot:\n\nggplot(data = sep2010, aes(x = wind, y = pressure)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n4.3.1 Storing a ggplot object\nIf you are going to reuse some of these components, you can store them in variables. We can save the ggplot object in an object called gg, and then add geom_point() to it.\n\ngg = ggplot(sep2010, aes(x = wind, y = pressure)) \n\ngg + geom_point()\n\n\n\n4.3.2 More Mappings\nWe can also map the variable category to the color of the points, by putting aes() inside the call to geom_point(), and specifying color = category\n\ngg + geom_point(aes(color = category))\n\n\n\n\n\n\n\n\nThis doesn’t alter the default aesthetic mappings that we defined previously, inside of ggplot(...). What it does is add an aesthetic mapping for this particular geom, geom_point(). If we added other geoms, this mapping would not apply to them.\n\n\n4.3.3 Setting Values\nContrast this aesthetic mapping with aesthetic setting. This time, we won’t use aes(); we’ll just set the value of color directly to \"red\". And we’ll also increase the size of the dots by setting size:\n\ngg + geom_point(color = \"red\", size = 3)\n\n\n\n\n\n\n\n\n\n\n4.3.4 Customizing Scales\nWe can also modify the scales; that is, the mappings from data to visual attributes. Here, we’ll change the \\(x\\) scale so that it has a larger range:\n\ngg + geom_point() + scale_x_continuous(limits = c(0, 150))\n\n\n\n\n\n\n\n\n\nIf we go back to the example with the color = category mapping, we can also modify the color scale and customize them with our own values:\n\ngg + \n  geom_point(aes(color = category), size = 2) +\n  scale_color_manual(values = c(\"blue\", \"magenta\", \"red\", \"cyan\"))\n\n\n\n\n\n\n\n\n\n\n4.3.5 Themes, Annotations, etc\nSome aspects of a graph’s appearance fall outside the scope of the grammar of graphics. These include the color of the background and grid lines in the graphing area, the fonts used in the axis labels, annotations, text in the graph title & subtitle, legend details, and things like that. These are controlled with auxiliary functions such as labs(), theme(), or annotate().\n\ngg + \n  geom_point(aes(color = category), size = 3) +\n  geom_text(aes(label = name), hjust = 0, nudge_x = 2, size = 3) +\n  scale_x_continuous(limits = c(0, 150)) +\n  scale_y_continuous(limits = c(900, 1010)) +\n  labs(title = \"Storms in North Atlantic formed during Sep-2010\",\n       subtitle = \"Negative association between wind and pressure\",\n       x = \"Maximum Wind Speed (kn)\",\n       y = \"Minimum Pressure (mbar)\") +\n  annotate(geom = \"text\", x = 26, y = 1005, label = \"hey!\", color = \"purple\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")"
  },
  {
    "objectID": "2-02-intro-dplyr.html",
    "href": "2-02-intro-dplyr.html",
    "title": "5  Data Manipulation with \"dplyr\"",
    "section": "",
    "text": "In the preceding chapter, we introduced some of the key ideas behind the Grammar of Graphics and their implementation through \"ggplot2\". In this chapter we move on with some of the basic notions behind \"dplyr\", specifically we introduce the set of functions commonly referred to as the basic dplyr verbs.\nTo continue the discussion, we use the sample data for tropical cyclones that formed during the month of September 2010 in the North Atlantic:"
  },
  {
    "objectID": "2-02-intro-dplyr.html#basic-dplyr-verbs",
    "href": "2-02-intro-dplyr.html#basic-dplyr-verbs",
    "title": "5  Data Manipulation with \"dplyr\"",
    "section": "5.1 Basic \"dplyr\" verbs",
    "text": "5.1 Basic \"dplyr\" verbs\nIn no particular order of importance, let’s start with the set of elementary \"dplyr\" functions known as the basic dplyr verbs:\n\nfilter(): select (i.e. keeping) rows that match a condition\nslice(): subset rows using their positions\nselect(): keep or drop columns using their names and types\nmutate(): modify existing variables, or add new variables\narrange(): reorder rows using column names\nsummarise(): reduce variables to values\ngroup_by(): grouped (aggregated) operations\n\n\n5.1.1 Filter\nfilter() allows you to select rows by defining a condition (which could be simple or compound). For example, we can filter sep2010 by selecting those tropical cyclones of category tropical storm (ts)\n\n# using a single condition\nfilter(sep2010, category == \"ts\")\n\n# A tibble: 4 × 5\n  name     wind pressure category  days\n  <chr>   <dbl>    <dbl> <chr>    <int>\n1 Gaston     35     1005 ts           1\n2 Hermine    60      989 ts           4\n3 Matthew    50      998 ts           3\n4 Nicole     40      994 ts           1\n\n\nWe can also use a compound logical condition: tropical storms having a wind speed greater than 40 knots\n\nfilter(sep2010, category == \"ts\" & wind > 40)\n\n# A tibble: 2 × 5\n  name     wind pressure category  days\n  <chr>   <dbl>    <dbl> <chr>    <int>\n1 Hermine    60      989 ts           4\n2 Matthew    50      998 ts           3\n\n\n\n\n5.1.2 Slice\nslice() allows you to subset rows using their positions, for example:\n\n# first row\nslice(sep2010, 1)\n\n# A tibble: 1 × 5\n  name    wind pressure category  days\n  <chr>  <dbl>    <dbl> <chr>    <int>\n1 Gaston    35     1005 ts           1\n\n\n\n# third row\nslice(sep2010, 3)\n\n# A tibble: 1 × 5\n  name   wind pressure category  days\n  <chr> <dbl>    <dbl> <chr>    <int>\n1 Igor    135      924 cat4        13\n\n\n\n# first three rows\nthree_rows = slice(sep2010, 1:3)\nthree_rows\n\n# A tibble: 3 × 5\n  name     wind pressure category  days\n  <chr>   <dbl>    <dbl> <chr>    <int>\n1 Gaston     35     1005 ts           1\n2 Hermine    60      989 ts           4\n3 Igor      135      924 cat4        13\n\n\n\n# specify a negative position\nslice(sep2010, -1)\n\n# A tibble: 7 × 5\n  name     wind pressure category  days\n  <chr>   <dbl>    <dbl> <chr>    <int>\n1 Hermine    60      989 ts           4\n2 Igor      135      924 cat4        13\n3 Julia     120      948 cat4         8\n4 Karl      110      956 cat3         4\n5 Lisa       75      982 cat1         6\n6 Matthew    50      998 ts           3\n7 Nicole     40      994 ts           1\n\n\nWe should note that slice() comes with a set of sibling functions such as:\n\nslice_head() to subset the first rows\nslice_tail() to subset the last rows\nslice_min() to subset rows with lowest values of a variable\nslice_max() to subset rows with highest values of a variable\nslice_sample() to randomly subset rows\n\n\n\n5.1.3 Select\nselect() allows you to select one or more columns by name:\n\nselect(sep2010, name, wind, pressure)\n\n# A tibble: 8 × 3\n  name     wind pressure\n  <chr>   <dbl>    <dbl>\n1 Gaston     35     1005\n2 Hermine    60      989\n3 Igor      135      924\n4 Julia     120      948\n5 Karl      110      956\n6 Lisa       75      982\n7 Matthew    50      998\n8 Nicole     40      994\n\n\nselect() also allows you to specify a range of consecutive columns via the : operator\n\n# consecutive columns\nselect(sep2010, name:pressure)\n\n# A tibble: 8 × 3\n  name     wind pressure\n  <chr>   <dbl>    <dbl>\n1 Gaston     35     1005\n2 Hermine    60      989\n3 Igor      135      924\n4 Julia     120      948\n5 Karl      110      956\n6 Lisa       75      982\n7 Matthew    50      998\n8 Nicole     40      994\n\n\nselect() also allows you to exclude one or more columns by negating their names:\n\n# exclude columns by name\nselect(sep2010, -(wind:category))\n\n# A tibble: 8 × 2\n  name     days\n  <chr>   <int>\n1 Gaston      1\n2 Hermine     4\n3 Igor       13\n4 Julia       8\n5 Karl        4\n6 Lisa        6\n7 Matthew     3\n8 Nicole      1\n\n\nInterestingly, you can also select() columns by their position\n\n# columns by position\nselect(sep2010, 1:3)\n\n# A tibble: 8 × 3\n  name     wind pressure\n  <chr>   <dbl>    <dbl>\n1 Gaston     35     1005\n2 Hermine    60      989\n3 Igor      135      924\n4 Julia     120      948\n5 Karl      110      956\n6 Lisa       75      982\n7 Matthew    50      998\n8 Nicole     40      994\n\n\n\n\n5.1.4 Mutate\nAnother basic verb is mutate() which allows you to: 1) transform existing variables, but also 2) add new variables.\nWind speed values—column wind—are expressed in knots. But what if we are interested in having wind speed expressed in miles per hour? Enter mutate(). Here is how to add a new column wind_mph (1 knot = 1.15078 mph)\n\nmutate(sep2010, wind_mph = wind * 1.15078)\n\n# A tibble: 8 × 6\n  name     wind pressure category  days wind_mph\n  <chr>   <dbl>    <dbl> <chr>    <int>    <dbl>\n1 Gaston     35     1005 ts           1     40.3\n2 Hermine    60      989 ts           4     69.0\n3 Igor      135      924 cat4        13    155. \n4 Julia     120      948 cat4         8    138. \n5 Karl      110      956 cat3         4    127. \n6 Lisa       75      982 cat1         6     86.3\n7 Matthew    50      998 ts           3     57.5\n8 Nicole     40      994 ts           1     46.0\n\n\nIf we just want to transform the existing values in column wind so that it is expressed in mph, then we simply mutate() it using the same variable name:\n\nmutate(sep2010, wind = wind * 1.15078)\n\n# A tibble: 8 × 5\n  name     wind pressure category  days\n  <chr>   <dbl>    <dbl> <chr>    <int>\n1 Gaston   40.3     1005 ts           1\n2 Hermine  69.0      989 ts           4\n3 Igor    155.       924 cat4        13\n4 Julia   138.       948 cat4         8\n5 Karl    127.       956 cat3         4\n6 Lisa     86.3      982 cat1         6\n7 Matthew  57.5      998 ts           3\n8 Nicole   46.0      994 ts           1\n\n\nRecall that, in order to permanently change the data, you need to assign the changes to an object:\n\nsep2010b <- mutate(sep2010, wind_mph = wind * 1.15078)\nsep2010b\n\n# A tibble: 8 × 6\n  name     wind pressure category  days wind_mph\n  <chr>   <dbl>    <dbl> <chr>    <int>    <dbl>\n1 Gaston     35     1005 ts           1     40.3\n2 Hermine    60      989 ts           4     69.0\n3 Igor      135      924 cat4        13    155. \n4 Julia     120      948 cat4         8    138. \n5 Karl      110      956 cat3         4    127. \n6 Lisa       75      982 cat1         6     86.3\n7 Matthew    50      998 ts           3     57.5\n8 Nicole     40      994 ts           1     46.0"
  },
  {
    "objectID": "2-02-intro-dplyr.html#reordering-rows-arrange",
    "href": "2-02-intro-dplyr.html#reordering-rows-arrange",
    "title": "5  Data Manipulation with \"dplyr\"",
    "section": "5.2 Reordering rows: arrange()",
    "text": "5.2 Reordering rows: arrange()\nThe next basic verb of \"dplyr\" is arrange() which allows you to reorder rows. For example, here’s how to arrange the rows of sep2010 by wind\n\n# order rows by wind (increasingly)\narrange(sep2010, wind)\n\n# A tibble: 8 × 5\n  name     wind pressure category  days\n  <chr>   <dbl>    <dbl> <chr>    <int>\n1 Gaston     35     1005 ts           1\n2 Nicole     40      994 ts           1\n3 Matthew    50      998 ts           3\n4 Hermine    60      989 ts           4\n5 Lisa       75      982 cat1         6\n6 Karl      110      956 cat3         4\n7 Julia     120      948 cat4         8\n8 Igor      135      924 cat4        13\n\n\nBy default arrange() sorts rows in increasing order. To arrange rows in descending order you need to use the auxiliary function desc().\n\n# order rows by wind (decreasingly)\narrange(sep2010, desc(wind))\n\n# A tibble: 8 × 5\n  name     wind pressure category  days\n  <chr>   <dbl>    <dbl> <chr>    <int>\n1 Igor      135      924 cat4        13\n2 Julia     120      948 cat4         8\n3 Karl      110      956 cat3         4\n4 Lisa       75      982 cat1         6\n5 Hermine    60      989 ts           4\n6 Matthew    50      998 ts           3\n7 Nicole     40      994 ts           1\n8 Gaston     35     1005 ts           1\n\n\nLast but not least, you can also pass more than one column for arranging purposes:\n\n# order rows by days, and then pressure\narrange(sep2010, days, pressure)\n\n# A tibble: 8 × 5\n  name     wind pressure category  days\n  <chr>   <dbl>    <dbl> <chr>    <int>\n1 Nicole     40      994 ts           1\n2 Gaston     35     1005 ts           1\n3 Matthew    50      998 ts           3\n4 Karl      110      956 cat3         4\n5 Hermine    60      989 ts           4\n6 Lisa       75      982 cat1         6\n7 Julia     120      948 cat4         8\n8 Igor      135      924 cat4        13"
  },
  {
    "objectID": "2-02-intro-dplyr.html#summarizing-values-with-summarise",
    "href": "2-02-intro-dplyr.html#summarizing-values-with-summarise",
    "title": "5  Data Manipulation with \"dplyr\"",
    "section": "5.3 Summarizing values with summarise()",
    "text": "5.3 Summarizing values with summarise()\nThe next verb is summarise(), which is also available as summarize(). Conceptually, this involves applying a function on one or more columns, in order to summarize values. This is probably easier to understand with one example.\nSay you are interested in calculating the average duration of all storms To do this “a la dplyr” you use summarise() as follows:\n\n# average duration\nsummarise(sep2010, avg_days = mean(days))\n\n# A tibble: 1 × 1\n  avg_days\n     <dbl>\n1        5\n\n\nWhat if you want to calculate some summary statistics for days: min, median, mean, and max?\n\n# some stats for days (dplyr)\nsummarise(\n  sep2010, \n  min = min(days),\n  median = median(days),\n  avg = mean(days),\n  max = max(days)\n)\n\n# A tibble: 1 × 4\n    min median   avg   max\n  <int>  <dbl> <dbl> <int>\n1     1      4     5    13"
  },
  {
    "objectID": "2-02-intro-dplyr.html#grouped-operations",
    "href": "2-02-intro-dplyr.html#grouped-operations",
    "title": "5  Data Manipulation with \"dplyr\"",
    "section": "5.4 Grouped operations",
    "text": "5.4 Grouped operations\nTo better appreciate the power of summarise(), we need to introduce another major \"dplyr\" basic verb: group_by(). This is the function that allows you to perform data aggregations, or grouped operations.\nLet’s see the combination of summarise() and group_by() to calculate the average number of days by category:\n\n# average days, grouped by category\nsummarise(\n  group_by(sep2010, category),\n  avg_days = mean(days)\n)\n\nHere’s a less simpler example: average days, by category, displayed in descending order by average days:\n\narrange(\n  summarise(\n    group_by(sep2010, category),\n    avg_days = mean(days)),\n  desc(avg_days)\n)"
  },
  {
    "objectID": "2-03-intro-pipes.html",
    "href": "2-03-intro-pipes.html",
    "title": "6  The Pipe Operators",
    "section": "",
    "text": "This part introduces the pipe operators, which allow you write function calls in a more human-readable way. This kind of operators can be extremely useful within tidyverse operations that require many steps.\nWe should note that there are two operators: %>% and |>"
  },
  {
    "objectID": "2-03-intro-pipes.html#basic-piping",
    "href": "2-03-intro-pipes.html#basic-piping",
    "title": "6  The Pipe Operators",
    "section": "6.1 Basic Piping",
    "text": "6.1 Basic Piping\nTo understand how the pipe operators work, let’s see a simple example. Suppose we want to generate three random numbers—following a uniform distribution—in the interval [0, 2]. We can do this with the function runif() as follows:\n\nset.seed(123)\nrand = runif(n = 3, min = 0, max = 2)\nrand\n\n[1] 0.5751550 1.5766103 0.8179538\n\n\nThe set.seed() function is used to set a random seed so that every time runif() is invoked, we get the same random numbers (for reproducibility purposes).\nAs you can tell, runif() takes three arguments:\n\nn: number of values\nmin: lower limit of the distribution\nmax: upper limit of the distribution\n\nIt turns out that we can use the pipe operators to compute the same output. Here is how:\n\nset.seed(123)\n3 |> runif(min = 0, max = 2)\n\n[1] 0.5751550 1.5766103 0.8179538\n\n\nSo what does the pipe do? It allows you to write a function call that takes at least 2 arguments, e.g. f(x, y), and express it into the call x |> f(y). In other words, you start with the first argument, then the pipe, then the function with the second (and more) arguments.\nKeep in mind that the preceding example is extremely basic and it does not show the full potential of the pipe. To better appreciate its capabilities, let’s move on to a more interesting example."
  },
  {
    "objectID": "2-03-intro-pipes.html#the-power-of-piping",
    "href": "2-03-intro-pipes.html#the-power-of-piping",
    "title": "6  The Pipe Operators",
    "section": "6.2 The Power of Piping",
    "text": "6.2 The Power of Piping\nConsider again the table sep2010\n\nsep2010\n\n# A tibble: 8 × 5\n  name     wind pressure category  days\n  <chr>   <dbl>    <dbl> <chr>    <int>\n1 Gaston     35     1005 ts           1\n2 Hermine    60      989 ts           4\n3 Igor      135      924 cat4        13\n4 Julia     120      948 cat4         8\n5 Karl      110      956 cat3         4\n6 Lisa       75      982 cat1         6\n7 Matthew    50      998 ts           3\n8 Nicole     40      994 ts           1\n\n\nSay we are interested in the wind speed of hurricanes, and that in addition to having speeds measured in knots we also want them in miles-per-hour (mph) and also in kilometers-per-hour (kph). And not only that, but we want to arrange the hurricanes in table sep10 by wind speed in increasing order.\n\nStep-by-step computations\nOne option is to do calculations step-by-step, storing the intermediate results in their own data objects.\n\n# manipulation step-by-step\ndat1 = filter(sep2010, category != \"ts\")\ndat2 = select(dat1, name, wind)\ndat3 = mutate(\n  dat2,\n  wind_mph = wind * 1.15078,\n  wind_kph = wind * 1.852)\ndat4 = arrange(dat3, wind)\ndat4\n\n# A tibble: 4 × 4\n  name   wind wind_mph wind_kph\n  <chr> <dbl>    <dbl>    <dbl>\n1 Lisa     75     86.3     139.\n2 Karl    110    127.      204.\n3 Julia   120    138.      222.\n4 Igor    135    155.      250.\n\n\n\n\n\n\n\nNested function calls\nAnother option, if you don’t want to name the intermediate results, requires wrapping the function calls inside each other:\n\n\n\n\n# inside-out style (hard to read)\narrange(\n  mutate(\n    select(\n      filter(sep2010, category != \"ts\"), \n      name, wind),\n    wind_mph = wind * 1.15078,\n    wind_kph = wind * 1.852),\n  wind)\n\n# A tibble: 4 × 4\n  name   wind wind_mph wind_kph\n  <chr> <dbl>    <dbl>    <dbl>\n1 Lisa     75     86.3     139.\n2 Karl    110    127.      204.\n3 Julia   120    138.      222.\n4 Igor    135    155.      250.\n\n\nThis is difficult to read because the order of the operations is from inside to out. And it can get particularly ugly when you want to do many operations at once, which doesn’t lead to particularly elegant code: the arguments are a long way away from the function.\nTo get around this problem, you can use a piper either %>% or |>.\n\n\n6.2.1 The pipe operator\nAs we mentioned, x |> f(y) turns into f(x, y) so you can use it to rewrite multiple operations that you can read left-to-right, top-to-bottom:\n\n# manipulation step-by-step\nsep2010 |> \n  filter(category != \"ts\") |>\n  select(name, wind) |>\n  mutate(\n    wind_mph = wind * 1.15078,\n    wind_kph = wind * 1.852) |>\n  arrange(wind)\n\n# A tibble: 4 × 4\n  name   wind wind_mph wind_kph\n  <chr> <dbl>    <dbl>    <dbl>\n1 Lisa     75     86.3     139.\n2 Karl    110    127.      204.\n3 Julia   120    138.      222.\n4 Igor    135    155.      250.\n\n\n\n\n\nNotice how convenient the pipe can be in this case. It is easier to read, you can follow the flow of commands in a linear way, and it allows you to write commands in a way that is very close to the mental (or verbal) order in which you are thinking of the operations to be performed."
  },
  {
    "objectID": "3-01-storms-year.html",
    "href": "3-01-storms-year.html",
    "title": "7  Inspecting Single Columns",
    "section": "",
    "text": "As we just saw, because storms is an object of class \"tibble\", when you type its name R displays the first 10 rows, which belong to storm Amy in 1975:\nFrom this output, it is obvious that the data contains at least one storm from 1975. But what other year values are present in the data?\nAccording to the manual documentation of storms (\"dplyr\" version 1.1.2):\nIn a more or less arbitrary way, let’s begin inspecting storms by focusing on column year."
  },
  {
    "objectID": "3-01-storms-year.html#basic-inspection-of-year",
    "href": "3-01-storms-year.html#basic-inspection-of-year",
    "title": "7  Inspecting Single Columns",
    "section": "7.1 Basic Inspection of Year",
    "text": "7.1 Basic Inspection of Year\nLet’s formalize our first exploratory question:\n\nWhat years have the data been collected for?\n\nTo answer this question, we need to work with column year. There are several ways in R to manipulate a column from a tabular object. Using \"dplyr\", there are two basic kinds of functions to extract variables: pull() and select().\n\n\n\n\n\nExtracting a column with dplyr functions “pull” and “select”\n\n\n\n\nLet’s do a sanity check of years. We can use the function pull() that pulls or extracts an entire column. Because there are thousands of values in year, let’s also use unique() to find out the set of year values in the data. First we pull the year, and then we identify unique occurrences:\n\nunique(pull(storms, year))\n\n [1] 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989\n[16] 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004\n[31] 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019\n[46] 2020 2021\n\n\n\n\n\nBased on this output, we can see that storms has records during a 47-year period since 1975 to 2021.\nThe same can be accomplished with unique() and select().\n\nunique(select(storms, year))\n\n# A tibble: 47 × 1\n    year\n   <dbl>\n 1  1975\n 2  1976\n 3  1977\n 4  1978\n 5  1979\n 6  1980\n 7  1981\n 8  1982\n 9  1983\n10  1984\n# ℹ 37 more rows\n\n\nCan you notice the difference between pull() and select()? The difference is minor but important. Conceptually speaking, both functions return the same values. However, the format of their output is not the same. Observe that select() returns output in a tibble format. In contrast, the output of pull() is not in a tabular format but rather in a vector (i.e. contiguous set of values).\nInterestingly, there is a third option that can be used to find the unique or distinct year values: using the function distinct()\n\ndistinct(storms, year)\n\n# A tibble: 47 × 1\n    year\n   <dbl>\n 1  1975\n 2  1976\n 3  1977\n 4  1978\n 5  1979\n 6  1980\n 7  1981\n 8  1982\n 9  1983\n10  1984\n# ℹ 37 more rows\n\n\nAgain, notice the tabular output returned by distinct().\n\n7.1.1 Barplot of year values\nLet’s keep using the values in column year to obtain our first visualization with \"ggplot2\" functions. You could certainly begin a visual exploration of other variables, but I think year is a good place to start because it’s a numeric variable, measured on a discrete scale, and this is a good candidate to use barcharts (the most popular type of graphic).\n\"ggplot2\" comes with a large number of functions to create almost any type of chart. Luckily for us, it already comes with predefined functions to graph barcharts. The syntax may seem a bit scary for beginners, but you will see that it follows a logical structure. Here’s the code to make a barplot of year values:\n\n# barchart of year values\nggplot(data = storms) + \n  geom_bar(mapping = aes(x = year))\n\n\n\n\n\n\n\n\nHow does the previous command work?\n\nFirst, we always call the ggplot() function, typically indicating the name of the table to be used with the data argument.\nThen, we add more components, or layers, using the plus + operator.\nIn this case we are adding just one layer: a geom_bar() component which is the geometric object for bars.\nTo tell ggplot() that year is the column in data = storms to be used for the x-axis, we map x = year inside the aes() function which stands for aesthetic mapping.\n\nWe should clarify that the meaning of “aesthetic” as used by \"ggplot2\" does not mean beautiful or pretty, instead it conserves its etymological meaning of perception. Simply put, aes() is the function that you use to tell ggplot() which variables of a data object will be mapped as visual attributes of graphical elements."
  },
  {
    "objectID": "3-01-storms-year.html#basic-inspection-of-month",
    "href": "3-01-storms-year.html#basic-inspection-of-month",
    "title": "7  Inspecting Single Columns",
    "section": "7.2 Basic inspection of month",
    "text": "7.2 Basic inspection of month\nNow that we have explored column year, we can move to the column month and perform a similar type of analysis. Using the same commands, all we have to do is change the name of the variable to month to see whether there are storms in all months:\n\nunique(pull(storms, month))\n\n [1]  6  7  8  9 10 11  5 12  4  1\n\n\nIn this case, it would be better if we sort() them:\n\nsort(unique(pull(storms, month)))\n\n [1]  1  4  5  6  7  8  9 10 11 12\n\n\nObserve that not all months have recorded storms, this is the case for February (2) and March (3). Is this something to be concerned about? How is it possible that there are no recorded data for February and March? For the inexperience analyst, asking this type of questions is fundamental. As a data scientist, you will be working with data sets for which you are not necessarily an expert in that particular field of application. Since you will also be interacting with some type of experts, you should ask them as many questions as possible to clarify your understanding of the data and its context.\nThe answer for not having storms in February and March is because these months have to do with the end of Winter and beginning of Spring in the North Atlantic, which is a period of time where tropical systems don’t get formed. In fact, Spring months such as April and May also don’t tend to be typical months for hurricanes. So a further thing to explore could involve computing the number of storms in April and May."
  },
  {
    "objectID": "3-01-storms-year.html#exercises",
    "href": "3-01-storms-year.html#exercises",
    "title": "7  Inspecting Single Columns",
    "section": "7.3 Exercises",
    "text": "7.3 Exercises\n1) Use pull(), and unique() to inspect the values in column day\n\n\nShow answer\nunique(pull(storms, day))\n\n\n\n2) Try to use sort() in order to arrange the unique values of day\n\n\nShow answer\nsort(unique(pull(storms, day)))\n\n\n\n3) Does the unique day values make sense? Are there days for which there seem to be no recorded storm data?\n\n\nShow answer\n# there are no days for which there is no recorded data\n\n\n\n4) Use \"ggplot2\" functions to graph a barchart for the values in columns day.\n\n\nShow answer\nggplot(data = storms) + \n  geom_bar(mapping = aes(x = day))\n\n\n\n5) Use \"ggplot2\" functions to graph a barchart for the values in columns month.\n\n\nShow answer\nggplot(data = storms) + \n  geom_bar(mapping = aes(x = month))\n\n\n\n6) Look at the cheatsheet for ggplot and locate the information for geom_bar(). With the barchart of month values, find out how to specify: border color, fill color. Also, see what happens when you specify alpha = 0.5. Also, find how to use scale_x_continuous() to adjust the breaks argument so that the x-axis scale displays numbers 1, 2, …, 12\n\n\nShow answer\nggplot(data = storms) + \n  geom_bar(mapping = aes(x = month),\n           color = \"white\", fill = \"blue\", alpha = 0.5) +\n  scale_x_continuous(breaks = 1:12)\n\n\n\n7) Look at the cheatsheet for ggplot and locate the information for background Themes, e.g. theme_bw(). With the barchart of month values, find out how to add theme theme_classic() to the previous barchart.\n\n\nShow answer\nggplot(data = storms) + \n  geom_bar(mapping = aes(x = month),\n           color = \"white\", fill = \"blue\", alpha = 0.5) +\n  scale_x_continuous(breaks = 1:12) +\n  theme_bw()\n\n\n\n8) Look at the cheatsheet for ggplot and locate the information for Labels. Find out how to add a title with labs() to one of your previous barcharts.\n\n\nShow answer\nggplot(data = storms) + \n  geom_bar(mapping = aes(x = month),\n           color = \"white\", fill = \"blue\", alpha = 0.5) +\n  scale_x_continuous(breaks = 1:12) +\n  theme_bw() +\n  labs(title = \"Distribution of Month records\")"
  },
  {
    "objectID": "3-02-storms-1975.html",
    "href": "3-02-storms-1975.html",
    "title": "8  Storms in 1975",
    "section": "",
    "text": "Let’s focus on those storms recorded in 1975. How do we select them? Computationally, this operation involves a logical condition: year == 1975. This condition means that, from all the available year values, we get those that match 1975. This is done via \"dplyr\" function filter()\nFirst, let’s create a subset storms75 by filtering those rows with year equal to 1975:\nOnce we have the set of storms that occurred in 1975, one possible question to ask is what unique() storms happened in that year:\nFrom the returned output, there are 8 unique storms recorded in 1975.\nRecall that a similar result can be obtained with distinct(), the difference being the way in which the output is returned, in this case under the format of a tibble:\nNow that we know there are three storms for 1975, it would be nice to count the number of rows or entries for each of them. \"dplyr\" allows us to do this with count(), passing the name of the table, and then the name of the column for which we want to get the counts or frequencies for:"
  },
  {
    "objectID": "3-02-storms-1975.html#visualizing-1975-data",
    "href": "3-02-storms-1975.html#visualizing-1975-data",
    "title": "8  Storms in 1975",
    "section": "8.1 Visualizing 1975 data",
    "text": "8.1 Visualizing 1975 data\nLet’s play a bit with those storms from 1975. More specifically, let’s visually explore the values of columns wind and pressure.\n\nselect(storms75, name, wind, pressure)\n\n# A tibble: 238 × 3\n   name   wind pressure\n   <chr> <int>    <int>\n 1 Amy      25     1013\n 2 Amy      25     1013\n 3 Amy      25     1013\n 4 Amy      25     1013\n 5 Amy      25     1012\n 6 Amy      25     1012\n 7 Amy      25     1011\n 8 Amy      30     1006\n 9 Amy      35     1004\n10 Amy      40     1002\n# ℹ 228 more rows\n\n\nWhat type of visual display can we use to graph wind speed? The answer to this question is based by determining which type of variable wind is. You would agree with us in saying that wind is a quantitative variable. So one graphing option can be either a histogram or a boxplot, which are statistical charts to visualize the distribution of quantitative variables.\n\n8.1.1 Histograms\nLet’s begin with a histogram. The associated geom_() function to plot a histogram is geom_histogram(). We are going to show you a syntax of ggplot() slightly different from the one we used for the barcharts. Carefully review the following code:\n\nggplot(data = storms75, aes(x = wind)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nYou should notice now that aes() is an argument of ggplot(), and not anymore an argument of the geometric-object function geom_histogram(). While this may be a bit confusing when learning about \"ggplot2\", it is a very flexible and powerful behavior of aes(). Again, the important part of aes() is to understand that this function allows you to tell ggplot() which variables in your data table are used as visual attributes of the corresponding geometric elements forming the plot.\nWe can change the default argument binwidth to get another version of the histogram, for example a bin-width of 5 units (i.e. width of 5 knots):\n\nggplot(data = storms75, aes(x = wind)) +\n  geom_histogram(binwidth = 5)\n\n\n\n\n\n\n\n\nor a bin-width of 10:\n\nggplot(data = storms75, aes(x = wind)) +\n  geom_histogram(binwidth = 10)\n\n\n\n\n\n\n\n\nNow, let’s reflect on what’s going on in each of the histograms. Do they make sense? How do we interpret each figure?\n\n\n8.1.2 Boxplots\nWhile ggplot() does what we ask it to do, the displays may not be the most useful, or meaningful. Why? Think what exactly it is that we are plotting. We know that in 1975 we have the following storms:\n\nunique75\n\n[1] \"Amy\"      \"Blanche\"  \"Caroline\" \"Doris\"    \"Eloise\"   \"Faye\"     \"Gladys\"  \n[8] \"Hallie\"  \n\n\nNone of the histograms are differentiating between any of the above storms. Rather, the visualization is just giving us a general view of the wind values, from the low 20’s to the 120’s, or to be more precise:\n\nsummary(pull(storms75, wind))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  20.00   30.00   50.00   52.42   65.00  120.00 \n\n\nHowever, we don’t really know if all the storms have the same minimum wind speed, or the same maximum wind speed. The good news is that we can tell ggplot() to take into account each different storm name. But now let’s use boxplots via geom_boxplot(), mapping name to the x-axis, and wind to the y-axis.\n\nggplot(data = storms75, aes(x = name, y = wind)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nNote how different the distribution of wind speed is in each storm. We can get an alternative plot with density curves thanks to the geom_density() function. The syntax in this case is different. Let’s first do it without separating storms, and then we do it taking into account the storm names.\n\n\n8.1.3 Density Curves\nHere’s the command that plots a density curve of wind, without distinguishing between storms. Observe also how the argument fill is set to color 'gray':\n\nggplot(data = storms75, aes(x = wind)) +\n  geom_density(fill = 'gray')\n\n\n\n\n\n\n\n\nAs you can tell, the density curve looks like the profile of a roller coaster, or like the silhouette of two mountain peaks. Is this a pattern followed by wind speed in all storms? Or is it just an artifact due to the fact that we are plotting data without taking into consideration the context of storms75?\nLet’s replot density of wind, but now distinguishing between each storm. We do this by mapping name to the color argument:\n\nggplot(data = storms75, aes(x = wind, color = name)) +\n  geom_density(aes(fill = name))\n\n\n\n\n\n\n\n\nAha! Now things look more interesting: the roller coaster shape of the first call to geom_density() turned out to be an artificial pattern. As you can tell from the above plot, each storm has its own different density curve.\nTo get a better visualization, we can take the previous command and add a bit of transparency to the colors, this is done with the argument alpha inside geom_density(). Note how arguments are specified inside geom_density(): we map name to the color-fill attribute of the curve inside aes(), but we set alpha = 0.5 outside aes():\n\nggplot(data = storms75, aes(x = wind, color = name)) +\n  geom_density(aes(fill = name), alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n8.1.4 Facets\nWe are going to take advantage of the preceding graphic to introduce another cool feature of \"ggplot2\" that allows us to split data based on categorical or discrete variables, in order to produce separated frames called facets.\nBelow is the previous command—without alpha transparency—adding a new layer given by facet_wrap() taking into account the name of the storms:\n\nggplot(data = storms75, aes(x = wind, color = name)) +\n  geom_density(aes(fill = name)) + \n  facet_wrap(~ name)\n\n\n\n\n\n\n\n\nIn this command we are creating facets by name. This means that we obtain a facet for each unique category of name. In other words, we get separated density curves, one for each storm. The syntax inside facet_wrap() uses the tilde ~ operator which is the formula operator in R. Basically, the command ~ name tells ggplot() to create facets “based on” or “conditioning on” the values of name.\nHere’s a question for your: Which of the three storms in 1975 was the strongest one (in terms of the amount of sustained wind speeds)?\nThe legend may be a bit redundant in this graphic. We can hide it by using the function theme() and the argument legend.position = \"none\"\n\nggplot(data = storms75, aes(x = wind, color = name)) +\n  geom_density(aes(fill = name)) + \n  facet_wrap(~ name) +\n  theme(legend.position = \"none\")"
  },
  {
    "objectID": "3-03-amy-1975.html",
    "href": "3-03-amy-1975.html",
    "title": "9  Storm Amy (1975)",
    "section": "",
    "text": "Let’s focus on storm Amy in 1975, subsetting storms75 to filter out just the rows of Amy into its own table\nThe same table can also be obtained with this alternative command applied on the entire storms tibble, and filtering using a compound logical condition:"
  },
  {
    "objectID": "3-03-amy-1975.html#exploring-wind",
    "href": "3-03-amy-1975.html#exploring-wind",
    "title": "9  Storm Amy (1975)",
    "section": "9.1 Exploring wind",
    "text": "9.1 Exploring wind\nLet’s keep exploring wind but now let’s do it chronologically, that is, graphing the wind values in the order that they were recorded (recall storms are tracked every six hours).\nWe begin with a scatterplot using geom_point(), and we specify that the x-axis should use a numeric sequence 1:nrow(amy75) from the first row till the last row of amy75, and wind for y-axis:\n\nggplot(data = amy75, aes(x = 1:nrow(amy75), y = wind)) +\n  geom_point()\n\n\n\n\n\n\n\n\nBecause the x-axis denotes progression over time, we can connect the dots with a line. A simple way to do this is by adding another layer to our plot, this time with geom_line()\n\nggplot(data = amy75, aes(x = 1:nrow(amy75), y = wind)) +\n  geom_point() + \n  geom_line()\n\n\n\n\n\n\n\n\nAs you can tell, Amy started to being recorded with wind speed of 25 knots, and then after (7 x 6) = 42 hours, its speed kept increasing to 30, 35, 40, and so on until reaching its maximum speed of 60 knots that lasted 54 hours (9 x 6).\nAt this point, we can ask about the status of Amy along its lifetime. One option is to map status to the color attribute of points:\n\nggplot(data = amy75, aes(x = 1:nrow(amy75), y = wind)) +\n  geom_point(aes(color = status)) + \n  geom_line()\n\n\n\n\n\n\n\n\nWe see that Amy started as a tropical depression, and then became a tropical storm, but never became a hurricane. For a storm to reach hurricane status, of category 1, it must have one-minute maximum sustained winds of at least 64 kn (33 m/s; 74 mph; 119 km/h)."
  },
  {
    "objectID": "3-03-amy-1975.html#exploring-pressure",
    "href": "3-03-amy-1975.html#exploring-pressure",
    "title": "9  Storm Amy (1975)",
    "section": "9.2 Exploring pressure",
    "text": "9.2 Exploring pressure\nWhat about the pressure values of Amy? We can produce a similar scatterplot with a line connecting the dots:\n\nggplot(data = amy75, aes(x = 1:nrow(amy75), y = pressure)) +\n  geom_point(aes(color = status)) + \n  geom_line()\n\n\n\n\n\n\n\n\nAs an exploratory exercise, we can also play with the size of points, the size (width) of lines, colors, etc. Here’s one suggestion graphing pressure and taking into account the wind speed reflected in the size of points and line segments:\n\nggplot(data = amy75, aes(x = 1:nrow(amy75), y = pressure)) +\n  geom_line(aes(linewidth = wind), lineend = \"round\", color = 'gray70') +\n  geom_point(aes(size = wind, color = status))\n\n\n\n\n\n\n\n\nIf you know a little bit about storms, you know that there’s actually an association between wind and pressure. But let’s pretend for a second that we don’t know much about tropical storms, hurricanes, and things like that. By looking at the previous chart, this should allows us to guess that something is going on between the pressure of a storm and its wind speed. As Amy becomes stronger, with higher winds, its pressure levels drop accordingly, suggesting a negative correlation, which is confirmed when we compute this statistic:\n\nsummarise(amy75, cor(wind, pressure))\n\n# A tibble: 1 × 1\n  `cor(wind, pressure)`\n                  <dbl>\n1                -0.956"
  },
  {
    "objectID": "3-03-amy-1975.html#exercises",
    "href": "3-03-amy-1975.html#exercises",
    "title": "9  Storm Amy (1975)",
    "section": "9.3 Exercises",
    "text": "9.3 Exercises\n1) Try to find out how to specify a logical condition to filter various years: for example, storms from years 1975, 1976, and 1977.\n\n\nShow answer\nfiltered1 = storms |>\n  filter(year == 1975 | year == 1976 | year == 1977)\n\n# equivalent\nfiltered1 = storms |>\n  filter(year %in% 1975:1977)\n\n\n\n2) Try to find out how to specify a logical condition to filter storms from year 1975 with wind values less than 100 knots.\n\n\nShow answer\nfiltered2 = storms |>\n  filter(year == 1975 & wind < 100)\n\n\n\n3) Use \"dplyr\" functions/commands to create a table (e.g. tibble) storm_names_1980s containing the name and year of storms recorded during the 1980s (i.e. from 1980 to 1989).\n\n\nShow answer\nstorm_names_1980s = storms |>\n  filter(year %in% 1980:1989) |>\n  select(name, year)\n\n\n\n4) Create boxplots of pressure, for storms in 1980. You can also try graphing violins (geom_violin()) instead of boxplots (geom_boxplot()).\n\n\nShow answer\nstorms |>\n  filter(year == 1980) |>\n  ggplot(aes(x = name, y = pressure)) +\n  geom_boxplot()\n\n\n\n5) Use \"ggplot2\" functions to make a single scatter plot of wind and pressure for all storms. Use status to add color to the dots.\n\n\nShow answer\nggplot(data = storms, \n       aes(x = wind, y = pressure, color = status)) +\n  geom_point()\n\n\n\n6) Use \"ggplot2\" functions to make a scatterplot of wind and pressure for all storms, faceting by month, and using status to differentiate by color.\n\n\nShow answer\nggplot(data = storms, \n       aes(x = wind, y = pressure, color = status)) +\n  geom_point() +\n  facet_wrap(~ month)\n\n\n\n7) Use \"ggplot2\" functions to make a scatterplot of wind and pressure for all storms, but now create facets based on month. Feel free to add some amount of alpha transparency to the color of dots. Likewise, include a title and subtitle.\n\n\nShow answer\nggplot(data = storms, \n       aes(x = wind, y = pressure, color = status)) +\n  geom_point(alpha = 0.3) +\n  facet_wrap(~ month) +\n  labs(title = \"Wind and Pressure\",\n       subtitle = \"Tropical storms in North Atlantic\")"
  },
  {
    "objectID": "3-04-summary-1975.html",
    "href": "3-04-summary-1975.html",
    "title": "10  Summarizing 1975 Data",
    "section": "",
    "text": "We’ve been working with the table storms75, which was obtained by filtering those rows with year equal to 1975:"
  },
  {
    "objectID": "3-04-summary-1975.html#group-by-operations",
    "href": "3-04-summary-1975.html#group-by-operations",
    "title": "10  Summarizing 1975 Data",
    "section": "10.1 Group-by Operations",
    "text": "10.1 Group-by Operations\nAnother common task when exploring data has to do with computations applied on certain groups or categories of data. \"dplyr\" provides the function group_by() which takes a data table, and we specify the column(s) on which rows will be grouped by:\n\n\n\n\n\nGroup-by operations\n\n\n\n\nFor example, we may be interested in calculating the average wind speed and average pressure of each storm in 1975. First we need to group by name, and then we use summarise() to indicate that we want to get the mean() of wind and pressure, like this:\n\nsummarise(\n  group_by(storms75, name),\n  avg_wind = mean(wind),\n  avg_pressure = mean(pressure)\n)\n\n# A tibble: 8 × 3\n  name     avg_wind avg_pressure\n  <chr>       <dbl>        <dbl>\n1 Amy          46.5         995.\n2 Blanche      45           999.\n3 Caroline     38.9        1002.\n4 Doris        67.1         988.\n5 Eloise       45           999.\n6 Faye         68.4         988.\n7 Gladys       66.3         986.\n8 Hallie       34.6        1005.\n\n\nSometimes, you’ll find convenient to assign the output into its own table:\n\navg_wind_pressure_75 <- summarise(\n  group_by(storms75, name),\n  avg_wind = mean(wind),\n  avg_pressure = mean(pressure)\n)\n\navg_wind_pressure_75\n\n# A tibble: 8 × 3\n  name     avg_wind avg_pressure\n  <chr>       <dbl>        <dbl>\n1 Amy          46.5         995.\n2 Blanche      45           999.\n3 Caroline     38.9        1002.\n4 Doris        67.1         988.\n5 Eloise       45           999.\n6 Faye         68.4         988.\n7 Gladys       66.3         986.\n8 Hallie       34.6        1005."
  },
  {
    "objectID": "3-04-summary-1975.html#arrange-operations",
    "href": "3-04-summary-1975.html#arrange-operations",
    "title": "10  Summarizing 1975 Data",
    "section": "10.2 Arrange operations",
    "text": "10.2 Arrange operations\nThe table of summary means avg_wind_pressure_75 is ordered alphabetically by name. But perhaps you may want to organize its contents by avg_wind or by avg_pressure. Let’s see how to do this.\nBesides group_by() operations, another common type of manipulation is the arragement of rows based on the values of one or more columns. In \"dplyr\", this can easily be achieved with the function arrange(). The way this function works is passing the name of the table, and then specifying one or more columns to order rows based on such values.\n\n\n\n\n\nArranging rows\n\n\n\n\nSay you want to arrange the contents of the average summary table, by taking into account the column avg_wind:\n\narrange(avg_wind_pressure_75, avg_wind)\n\n# A tibble: 8 × 3\n  name     avg_wind avg_pressure\n  <chr>       <dbl>        <dbl>\n1 Hallie       34.6        1005.\n2 Caroline     38.9        1002.\n3 Blanche      45           999.\n4 Eloise       45           999.\n5 Amy          46.5         995.\n6 Gladys       66.3         986.\n7 Doris        67.1         988.\n8 Faye         68.4         988.\n\n\nLikewise, you can also arrange the averages by avg_pressure:\n\narrange(avg_wind_pressure_75, avg_pressure)\n\n# A tibble: 8 × 3\n  name     avg_wind avg_pressure\n  <chr>       <dbl>        <dbl>\n1 Gladys       66.3         986.\n2 Faye         68.4         988.\n3 Doris        67.1         988.\n4 Amy          46.5         995.\n5 Eloise       45           999.\n6 Blanche      45           999.\n7 Caroline     38.9        1002.\n8 Hallie       34.6        1005.\n\n\nThe default behavior of arrange() is to organize rows in increasing order. But what if you want to organize rows in decreasing order? No problem, just use the auxiliary function desc() to indicate that rows should be arranged decreasingly:\n\narrange(avg_wind_pressure_75, desc(avg_wind))\n\n# A tibble: 8 × 3\n  name     avg_wind avg_pressure\n  <chr>       <dbl>        <dbl>\n1 Faye         68.4         988.\n2 Doris        67.1         988.\n3 Gladys       66.3         986.\n4 Amy          46.5         995.\n5 Blanche      45           999.\n6 Eloise       45           999.\n7 Caroline     38.9        1002.\n8 Hallie       34.6        1005."
  },
  {
    "objectID": "3-04-summary-1975.html#further-inspection-of-1975-storm-amy",
    "href": "3-04-summary-1975.html#further-inspection-of-1975-storm-amy",
    "title": "10  Summarizing 1975 Data",
    "section": "10.3 Further inspection of 1975 storm Amy",
    "text": "10.3 Further inspection of 1975 storm Amy\nLet’s focus on a specific storm, for example storm Amy in 1975. For sake of simplicity, we are going to create a table amy75 containing the values of this storm:\n\namy75 <- filter(storms75, name == \"Amy\")\namy75\n\n# A tibble: 31 × 13\n   name   year month   day  hour   lat  long status      category  wind pressure\n   <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <fct>          <dbl> <int>    <int>\n 1 Amy    1975     6    27     0  27.5 -79   tropical d…       NA    25     1013\n 2 Amy    1975     6    27     6  28.5 -79   tropical d…       NA    25     1013\n 3 Amy    1975     6    27    12  29.5 -79   tropical d…       NA    25     1013\n 4 Amy    1975     6    27    18  30.5 -79   tropical d…       NA    25     1013\n 5 Amy    1975     6    28     0  31.5 -78.8 tropical d…       NA    25     1012\n 6 Amy    1975     6    28     6  32.4 -78.7 tropical d…       NA    25     1012\n 7 Amy    1975     6    28    12  33.3 -78   tropical d…       NA    25     1011\n 8 Amy    1975     6    28    18  34   -77   tropical d…       NA    30     1006\n 9 Amy    1975     6    29     0  34.4 -75.8 tropical s…       NA    35     1004\n10 Amy    1975     6    29     6  34   -74.8 tropical s…       NA    40     1002\n# ℹ 21 more rows\n# ℹ 2 more variables: tropicalstorm_force_diameter <int>,\n#   hurricane_force_diameter <int>\n\n\nHere’s a couple of questions that we could investigate:\n\nwhich are the status categories for Amy?\nduring which months was Amy active? and for how many days?\nwhat are the basic summary statistics for wind and pressure?\n\n\n# which are the `status` categories for Amy?\ndistinct(amy75, status)\n\n# A tibble: 3 × 1\n  status             \n  <fct>              \n1 tropical depression\n2 tropical storm     \n3 extratropical      \n\n\n\n# during which months was Amy active?\ndistinct(amy75, month)\n\n# A tibble: 2 × 1\n  month\n  <dbl>\n1     6\n2     7\n\n\n\n# for how many days was Amy active?\ncount(distinct(amy75, day))\n\n# A tibble: 1 × 1\n      n\n  <int>\n1     8\n\n\n\n# summary statistics for wind\nsummary(select(amy75, wind))\n\n      wind      \n Min.   :25.00  \n 1st Qu.:32.50  \n Median :50.00  \n Mean   :46.45  \n 3rd Qu.:60.00  \n Max.   :60.00  \n\n\n\n# summary statistics for pressure\nsummary(select(amy75, pressure))\n\n    pressure     \n Min.   : 981.0  \n 1st Qu.: 986.0  \n Median : 987.0  \n Mean   : 995.1  \n 3rd Qu.:1005.0  \n Max.   :1013.0"
  },
  {
    "objectID": "3-04-summary-1975.html#exercises",
    "href": "3-04-summary-1975.html#exercises",
    "title": "10  Summarizing 1975 Data",
    "section": "10.4 Exercises",
    "text": "10.4 Exercises\n1) Create a table (e.g. tibble) storms_count_75 by filter()-ing storms in year 1975, and count()-ing their names. This table will give the counts (i.e. number of entries) of each storm in 1975.\n\n\nShow answer\nstorms_count_75 = storms |>\n  filter(year == 1975) |>\n  count(name)\n\n\n\n2) Create a table (e.g. tibble) storms_count_70s by filter()-ing storms in years 1975 to 1979, count()-ing by year and name, and then doing a second count() just by year. This table will give the number of storms in each year frmo 175 to 1979.\n\n\nShow answer\nstorms_count_70s = storms |>\n  filter(year < 1980) |>\n  count(year, name) |>\n  count(year)\n\n\n\n3) Use \"dplyr\" functions/commands to create a table (e.g. tibble) max_wind_pressure_75 of storms in 1975 containing columns: 1) name of storm, 2) max_wind maximum wind speed, and 3) max_pressure maximum pressure.\n\n\nShow answer\nmax_wind_pressure_75 = storms |>\n  filter(year == 1975) |>\n  group_by(name) |>\n  summarise(\n    max_wind = max(wind),\n    max_pressure = max(pressure)\n  )\n\n\n\n4) Use \"dplyr\" functions/commands to create a table (e.g. tibble) wind_stats_75 of storms in 1975 containing columns: 1) name of storm, 2) min_wind minimum wind speed, 3) avg_wind mean wind speed, 4) med_wind median wind speed, and 5) max_wind maximum wind speed.\n\n\nShow answer\nwind_stats_75 = storms |>\n  filter(year == 1975) |>\n  group_by(name) |>\n  summarise(\n    min_wind = min(wind),\n    avg_wind = mean(wind),\n    med_wind = median(wind),\n    max_wind = max(wind)\n  )"
  },
  {
    "objectID": "3-05-eda-1975.html",
    "href": "3-05-eda-1975.html",
    "title": "11  Summary",
    "section": "",
    "text": "So far, we’ve covered several functions from \"dplyr\", as well as some other functions in R:"
  },
  {
    "objectID": "3-05-eda-1975.html#number-of-storms-per-year",
    "href": "3-05-eda-1975.html#number-of-storms-per-year",
    "title": "11  Summary",
    "section": "11.1 Number of Storms per Year",
    "text": "11.1 Number of Storms per Year\n\n\n\nIf you recall, our first ggplot involved a barchart for the values in column year\n\nggplot(data = storms) + \n  geom_bar(aes(x = year))\n\n\n\n\nWe discovered that the 47-year period of recorded data from 1975 to 2021. We can take a further step and ask: how many storms are there in each year?\nTo answer this question, we need to do some data manipulation with \"dplyr\". Our general recommendation when working with \"dplyr\"’s functions, especially when you are learning about them, is to do computations step by step, deciding which columns you need to use, which rows to consider, which functions to call, and so on.\nThink about the columns that we need to select to find the number of unique storms per year. We obviously need year, but this column alone it’s not enough because for any given storm we have multiple records with the same year. Therefore, we also need column name.\nFor illustration purposes, we are going to build the data manipulation pipeline step by step. As you get more comfortable with \"dplyr\" and other functions, you won’t have the need to dissect every single command.\nA first step is to select() variables year and name:\n\nselect(storms, year, name)\n\n# A tibble: 19,066 × 2\n    year name \n   <dbl> <chr>\n 1  1975 Amy  \n 2  1975 Amy  \n 3  1975 Amy  \n 4  1975 Amy  \n 5  1975 Amy  \n 6  1975 Amy  \n 7  1975 Amy  \n 8  1975 Amy  \n 9  1975 Amy  \n10  1975 Amy  \n# ℹ 19,056 more rows\n\n\nNext, we need to group_by() year. At first glance, the previous output and the output below seem identical. But notice the tiny difference: the output below has a second line of text with some relevant information telling us that the values are grouped by year.\n\ngroup_by(select(storms, year, name), year)\n\n# A tibble: 19,066 × 2\n# Groups:   year [47]\n    year name \n   <dbl> <chr>\n 1  1975 Amy  \n 2  1975 Amy  \n 3  1975 Amy  \n 4  1975 Amy  \n 5  1975 Amy  \n 6  1975 Amy  \n 7  1975 Amy  \n 8  1975 Amy  \n 9  1975 Amy  \n10  1975 Amy  \n# ℹ 19,056 more rows\n\n\nThen, we identify the distinct() values (combination of year-name):\n\ndistinct(group_by(select(storms, year, name), year))\n\n# A tibble: 639 × 2\n# Groups:   year [47]\n    year name    \n   <dbl> <chr>   \n 1  1975 Amy     \n 2  1975 Blanche \n 3  1975 Caroline\n 4  1975 Doris   \n 5  1975 Eloise  \n 6  1975 Faye    \n 7  1975 Gladys  \n 8  1975 Hallie  \n 9  1976 Belle   \n10  1976 Dottie  \n# ℹ 629 more rows\n\n\nFor convenience purposes, let’s assign this table into its own object, which we can call storms_year_name\n\nstorms_year_name <- distinct(group_by(select(storms, year, name), year))\n\nFinally, we need to count() how many storms are in each year:\n\ncount(storms_year_name, year)\n\n# A tibble: 47 × 2\n# Groups:   year [47]\n    year     n\n   <dbl> <int>\n 1  1975     8\n 2  1976     7\n 3  1977     6\n 4  1978    11\n 5  1979     8\n 6  1980    11\n 7  1981    11\n 8  1982     5\n 9  1983     4\n10  1984    12\n# ℹ 37 more rows\n\n\nAll the previous commands can be assembled together with various embedded lines of code:\n\nstorms_per_year <- storms |>\n  select(year, name) |>\n  group_by(year) |>\n  distinct() |>\n  count()\n\nstorms_per_year\n\n# A tibble: 47 × 2\n# Groups:   year [47]\n    year     n\n   <dbl> <int>\n 1  1975     8\n 2  1976     7\n 3  1977     6\n 4  1978    11\n 5  1979     8\n 6  1980    11\n 7  1981    11\n 8  1982     5\n 9  1983     4\n10  1984    12\n# ℹ 37 more rows\n\n\nNow that we have the counts or frequencies, we can make our next barchart. In this case, we will use the table storms_year_name as the input data for ggplot():\n\nggplot(data = storms_year_name) + \n  geom_bar(aes(x = year))\n\n\n\n\nBy looking at the chart, there are some fairly tall bars. Although it’s hard to see exactly which years have a considerably large number of storms, eyeballing things out it seems that around 1995, 2003, 2005, and 2010 there are 20 or more storms. We can find the actual answer by using arrange(), specifying the counts to be shown in descending order—with desc():\n\narrange(storms_per_year, desc(n))\n\n# A tibble: 47 × 2\n# Groups:   year [47]\n    year     n\n   <dbl> <int>\n 1  2020    30\n 2  2005    29\n 3  1995    21\n 4  2003    21\n 5  2010    21\n 6  2011    20\n 7  2021    20\n 8  2012    19\n 9  2000    18\n10  2017    18\n# ℹ 37 more rows\n\n\nAs you can tell, in the 41-year period from 1975 to 2015, there are two years, 1995 and 2005, with a maximum number of storms equal to 21."
  },
  {
    "objectID": "3-05-eda-1975.html#exercises",
    "href": "3-05-eda-1975.html#exercises",
    "title": "11  Summary",
    "section": "11.2 Exercises",
    "text": "11.2 Exercises\n1) Use \"dplyr\" functions/commands to create a table (e.g. tibble) storm_records_per_year containing three columns: 1) year of storm, 2) name of storm, and 3) count for number of recorded values (of the corresponding storm).\n\n\nShow answer\nstorm_records_per_year = storms |>\n  group_by(year) |>\n  count(name, name = \"count\")\n\n\n\n2) Use \"dplyr\" functions/commands to create a table (e.g. tibble) storms_categ5 containing the name and year of those storms of category 5.\n\n\nShow answer\nstorms_categ5 = storms |>\n  filter(wind >= 137) |>\n  group_by(year) |>\n  count(name, year) |>\n  select(name, year)\n\n\n\n3) Use \"dplyr\" functions/commands to obtain a hurricanes_stats table showing the avg_pressure (average pressure), and avg_wind (average wind speed), for each type of hurricane category. This table should contain no missing data, and three columns: 1) category, 2) avg_pressure, and 3) avg_wind.\n\n\nShow answer\nhurricanes_stats = storms |>\n  filter(!is.na(category)) |>\n  group_by(category) |>\n  summarise(\n    avg_pressure = mean(pressure),\n    avg_wind = mean(wind)\n  )\n\n\n\n4) Use \"dplyr\" functions/commands to create a table (e.g. tibble) max_wind_per_storm containing three columns: 1) year of storm, 2) name of storm, and 3) max_wind maximum wind speed record (for that storm).\n\n\nShow answer\nmax_wind_per_storm = storms |>\n  group_by(year, name) |>\n  summarise(max_wind = max(wind))\n\n\n\n5) Use \"dplyr\" functions/commands to create a table (e.g. tibble) max_wind_per_year containing three columns: 1) year of storm, 2) name of storm, and 3) wind maximum wind speed record (for that year). Arrange rows by wind speed in decreasing order.\n\n\nShow answer\nmax_wind_per_year = storms |>\n  group_by(year) |>\n  summarise(max_wind = max(wind)) |>\n  arrange(desc(max_wind))"
  },
  {
    "objectID": "4-01-counting-storms.html",
    "href": "4-01-counting-storms.html",
    "title": "12  Counting Tropical Systems",
    "section": "",
    "text": "In chapter Summary we quickly explored the values in column year, discovering the 47-year period of recorded data from 1975 to 2021. We can take a further step and ask:\n\nHow many storms are there in each year?\n\n\n\n\nTo answer this question, we need to do some data manipulation. My general recommendation when working with \"dplyr\"’s functions, especially when you are learning about them, is to do computations step by step, deciding which columns you need to use, which rows to consider, which functions to call, and so on.\n\nAttempt Number 1\nTo find the number of storms per year, think about the columns that you need to select. Also think about the operations that seem to be required to get such count. You obviously need to select year; and you need to count(). With this initial setting, you could assemble the following pipeline of commands:\n\n# first attempt\nstorms |>\n  select(year) |>\n  count()\n\n# A tibble: 1 × 1\n      n\n  <int>\n1 19066\n\n\nOkay. This count is not what we are looking for. But before trying other ideas, spend some time reflecting on what the preceding command is doing.\n\n\nAttempt Number 2\nPerhaps we could add a group_by(year) operation before invoking count():\n\n# second attempt\nstorms |>\n  select(year) |>\n  group_by(year) |>\n  count()\n\n# A tibble: 47 × 2\n# Groups:   year [47]\n    year     n\n   <dbl> <int>\n 1  1975   238\n 2  1976   126\n 3  1977    92\n 4  1978   152\n 5  1979   324\n 6  1980   335\n 7  1981   311\n 8  1982   111\n 9  1983    88\n10  1984   342\n# ℹ 37 more rows\n\n\nThis result looks more interesting. The returned output is a table with two columns: year and n. But after careful inspection, you should notice something awkward. While the first column makes complete sense, the second column n does not seem to be very helpful. Are there really 86 tropical systems in 1975? Are there 52 systems in 1976? And so on, and so forth? Of course not; 1975 did not have 86 systems. The numeric values under column n simply refer to the number of entries (i.e. rows) associated to each year.\nYou may not know this, but the previous table of counts can be obtained using a more compact command without the need to use select() and group_by(); you can just simply invoke count(year):\n\n# same output of preceding command, only using count()\nstorms |> count(year)\n\n# A tibble: 47 × 2\n    year     n\n   <dbl> <int>\n 1  1975   238\n 2  1976   126\n 3  1977    92\n 4  1978   152\n 5  1979   324\n 6  1980   335\n 7  1981   311\n 8  1982   111\n 9  1983    88\n10  1984   342\n# ℹ 37 more rows\n\n\n\n\nAttempt Number 3\nWhat if instead of counting year we count based on column name? For example:\n\n# third attempt\nstorms |> count(name)\n\n# A tibble: 258 × 2\n   name         n\n   <chr>    <int>\n 1 AL011993    11\n 2 AL012000     4\n 3 AL021992     5\n 4 AL021994     6\n 5 AL021999     4\n 6 AL022000    12\n 7 AL022001     5\n 8 AL022003     4\n 9 AL022006    13\n10 AL031987    32\n# ℹ 248 more rows\n\n\nMmm. Again, not the count that we are looking for. On a side note, observe the values displayed in the first rows of the returned table: e.g. AL011993, AL012000. These alphanumeric names correspond to names of tropical depressions that never reached tropical storm status. In other words, those system were not strong enough to be given a name, e.g. Amy, Caroline, Doris, etc.\n\n\nAttempt Number 4\nSo far we’ve tried—unsuccessfully—counting based on column year alone, and also on column name alone. None of these columns, in and of itself, is enough because for any given storm or any given year we have multiple entries with duplicated values.\nAgain, the following suggestion may not seem obvious, but you can also try counting by taking into account both year and name\n\n# fourth attempt\nstorms |> count(year, name)\n\n# A tibble: 639 × 3\n    year name         n\n   <dbl> <chr>    <int>\n 1  1975 Amy         31\n 2  1975 Blanche     20\n 3  1975 Caroline    33\n 4  1975 Doris       29\n 5  1975 Eloise      46\n 6  1975 Faye        19\n 7  1975 Gladys      46\n 8  1975 Hallie      14\n 9  1976 Belle       18\n10  1976 Candice     11\n# ℹ 629 more rows\n\n\nCompared to the previous attempts, this output looks more promising. Finally, we can see that there were three (named) storms in 1975, two in 1976, three more in 1977, etc. However, we still don’t have those specific counts: 3, 2, 3, etc. But at least we are making some progress in what it seems to be the right direction.\n\n\nAttempt Number 5\nWhy not taking the preceding command, and adding an extra count() but only considering year?\n\n# fifth attempt\nstorms |> count(year, name) |> count(year)\n\n# A tibble: 47 × 2\n    year     n\n   <dbl> <int>\n 1  1975     8\n 2  1976     7\n 3  1977     6\n 4  1978    11\n 5  1979     8\n 6  1980    11\n 7  1981    11\n 8  1982     5\n 9  1983     4\n10  1984    12\n# ℹ 37 more rows\n\n\nVoila! Now we are talking. This table contains precisely the counts that we are looking for: number of systems in each year.\nFor convenience purposes, let’s assign this table into its own object, which we can call system_counts_per_year, or some other meaningful name that you might prefer to use:\n\nsystem_counts_per_year <- storms |> \n  count(year, name) |> \n  count(year)\n\nsystem_counts_per_year\n\n# A tibble: 47 × 2\n    year     n\n   <dbl> <int>\n 1  1975     8\n 2  1976     7\n 3  1977     6\n 4  1978    11\n 5  1979     8\n 6  1980    11\n 7  1981    11\n 8  1982     5\n 9  1983     4\n10  1984    12\n# ℹ 37 more rows\n\n\nNow that we have the counts or frequencies, it would be nice to visualize them with a barchart, like the following one:\n\n\n\n\n\nLet’s discuss how to obtain this kind of graphic in the next chapter."
  },
  {
    "objectID": "4-02-barcharts.html",
    "href": "4-02-barcharts.html",
    "title": "13  Visualizing Number of Systems",
    "section": "",
    "text": "We ended the preceding chapter with the following command that allows us to get the number of tropical systems in each year from 1975 to 2020:\nLet’s now talk about how to use \"ggplot2\" functions to obtain a data visualization of the above frequencies."
  },
  {
    "objectID": "4-02-barcharts.html#barcharts",
    "href": "4-02-barcharts.html#barcharts",
    "title": "13  Visualizing Number of Systems",
    "section": "13.1 Barcharts",
    "text": "13.1 Barcharts\nIn chapter 4, we created a basic barchart of all year values. To be more precise, we obtained a barchart based on all the entries for each given year by invoking the command shown below:\n\n# previously we got a barchart of year values\nggplot(data = storms) + \n  geom_bar(aes(x = year))\n\n\n\n\nAs you can tell, the geometric object (geom) function that is used in this case is geom_bar(). This function, by default, does its own computation—via stat_count()—to get the counts or frequencies.\n\n13.1.1 Barchart with geom_bar()\nIt feels very tempting and natural to use the same \"ggplot2\" functions of the preceding command in order to create a bar-plot for the number of tropical systems in each year. After all, this is exactly the type of chart we want to produce. So why not using geom_bar()? Let’s try this out.\n\n# doesn't work as expected\nggplot(data = system_counts_per_year) + \n  geom_bar(aes(x = year))\n\n\n\n\nOoops!\nWhat is going on with this graphic? Why do all bars have the same height? And why the y-axis has a count scale from 0 to 1? This doesn’t make any sense.\nWell, the explanation has to do with the technical fact that, as we just said, by default geom_bar() does its own tally of year values.\nBecause the table system_counts_per_year already has the frequencies in column n, we need to tell geom_bar() to not count anything. This is done by adding a y argument to the aesthetic mapping function aes(), and also by setting the argument stat = \"identity\"\n\n# this works\nggplot(data = system_counts_per_year) + \n  geom_bar(aes(x = year, y = n), stat = \"identity\")\n\n\n\n\n\n\n13.1.2 Barchart with geom_col()\nOften, there is more than one way to obtain a given output or a given graphic. Interestingly, in this case we can also get a barchart with the geom_col() function. This is a sibling function of geom_bar(stat = \"identity\"), designed to be used for tables of frequencies, like system_counts_per_year:\n\n# another way to get a barchart, given a table of frequencies\nggplot(data = system_counts_per_year) +\n  geom_col(aes(x = year, y = n))\n\n\n\n\nLooking at the chart, there are some fairly tall bars. Although it’s hard to see exactly which years have a considerably large number of tropical systems, eyeballing things out it seems that around 1995, 2005, and 2020 there are 20 or more storms. We can find the actual answer by using arrange(), specifying the counts to be shown in descending order—with desc():\n\narrange(system_counts_per_year, desc(n))\n\n# A tibble: 47 × 2\n    year     n\n   <dbl> <int>\n 1  2020    30\n 2  2005    29\n 3  1995    21\n 4  2003    21\n 5  2010    21\n 6  2011    20\n 7  2021    20\n 8  2012    19\n 9  2000    18\n10  2017    18\n# ℹ 37 more rows\n\n\nAs you can tell, in the 45-year period from 1975 to 2020, the top three years by number of systems correspond to 2020, 1995 and 2005."
  },
  {
    "objectID": "4-02-barcharts.html#customizing-a-barchart",
    "href": "4-02-barcharts.html#customizing-a-barchart",
    "title": "13  Visualizing Number of Systems",
    "section": "13.2 Customizing a Barchart",
    "text": "13.2 Customizing a Barchart\nFor illustration purposes, let’s further customize the bar plot by adding a title, a more descriptive y-axis label, a simple background theme, and things like that. For instance, the function labs() can be used to customize a title, a subtitle, as well as axis labels. Likewise, the theme_minimal() function provides a simplified background theme that, in my opinion, gives a neat look to the graphic.\n\nggplot(data = system_counts_per_year) +\n  geom_col(aes(x = year, y = n)) +\n  labs(title = \"Number of tropical systems per year\",\n       subtitle = \"(1975-2020)\",\n       y = \"count\") +\n  theme_minimal()\n\n\n\n\n\n13.2.1 Global versus Local Aesthetic Mappings\nAn equivalent way to get the above plot can be obtained if we move the mapping aes() inside ggplot().\n\nggplot(data = system_counts_per_year, aes(x = year, y = n)) +\n  geom_col() +\n  labs(title = \"Number of tropical systems per year\",\n       subtitle = \"(1975-2020)\",\n       y = \"count\") +\n  theme_minimal()\n\nRelocating the mapping command aes() may seem a bit whimsical. What difference it makes if we place aes() inside ggplot() versus if we place it inside geom_col()? It turns out that there is an important difference. Any mapping done at the level of ggplot() is considered to be a global mapping in the sense that this cascades down to any additional layer, such as geom_col(). In contrast, any mapping done at the level of a geom_...() function or any other layer function acts as a local mapping, only affecting that particular type of geometric object.\nTo further illustrate the effect of aes(), let’s add a smoother to highlight the increasing trend that the number of storms have experienced in the visualized period of time. To do this, we add a new layer using stat_smooth() with arguments method = \"loess\" and se = FALSE\n\nggplot(data = system_counts_per_year, aes(x = year, y = n)) +\n  geom_col(fill = \"gray50\") +\n  stat_smooth(method = \"loess\", se = FALSE) +\n  labs(title = \"Number of tropical systems per year\",\n       subtitle = \"(1975-2020)\",\n       y = \"count\") +\n  theme_minimal()\n\n\n\n\nThe argument method = \"loess\" uses a non-linear smoother; in turn, se = FALSE prevents the standard error ribbon from being plotted. Observe also that the fill color of the bars has been changed to a less darker gray in order to better distinguish the blue smoother.\nCompare the above command with the following one in which the aesthetic mapping aes(x = year, y = n) is done at the geom_col() level:\n\n# error\nggplot(data = system_counts_per_year) +\n  geom_col(aes(x = year, y = n), fill = \"gray50\") +\n  stat_smooth(method = \"loess\", se = FALSE) +\n  labs(title = \"Number of tropical systems per year\",\n       subtitle = \"(1975-2020)\",\n       y = \"count\") +\n  theme_minimal()\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nError in `stat_smooth()`:\n! Problem while computing stat.\nℹ Error occurred in the 2nd layer.\nCaused by error in `compute_layer()`:\n! `stat_smooth()` requires the following missing aesthetics: x and y\n\n\nOh no! Houston, we have a problem.\nEvery time you get an error message, do the following two things:\n\nFirst, don’t panic,\nSecond, read the error message.\n\nAs you can tell, the error indicates that stat_smooth() requires missing aesthetics: x and y.\nYou may argue that those statistics, x and y, are already specified in aes(), inside geom_col(). And you are correct. But this is precisely the issue. Those aesthetics only work for geom_col(), not for stat_smooth(). One option to fix this problem is by including the same mapping into stat_smooth()\n\n# fixing the error\nggplot(data = system_counts_per_year) +\n  geom_col(aes(x = year, y = n), fill = \"gray50\") +\n  stat_smooth(aes(x = year, y = n), method = \"loess\", se = FALSE) +\n  labs(title = \"Number of tropical systems per year\",\n       subtitle = \"(1975-2020)\",\n       y = \"count\") +\n  theme_minimal()\n\nWhile this fixes the problem, we’ve introduced unnecessary duplication into our code. Why? Because the mapping command aes(x = year, y = n) appears in two different places. A better option is to simply use one call to aes() at the top ggplot()level. In this form the mapping propagates to both geom_col() and stat_smooth()\n\n# getting rid of the duplicated piece of code\nggplot(data = system_counts_per_year, aes(x = year, y = n)) +\n  geom_col(fill = \"gray50\") +\n  stat_smooth(method = \"loess\", se = FALSE) +\n  labs(title = \"Number of tropical systems per year\",\n       subtitle = \"(1975-2020)\",\n       y = \"count\") +\n  theme_minimal()"
  },
  {
    "objectID": "4-03-counting-more-systems.html",
    "href": "4-03-counting-more-systems.html",
    "title": "14  Counting More Systems",
    "section": "",
    "text": "In the two previous chapters you learned how to count the number of tropical systems in each year, and how to graph a barchart of such counts.\nIn this chapter, we continue discussing how to obtain more counts. Specifically, we describe how to get the frequencies of say tropical depressions, or tropical storms, or hurricanes, or major hurricanes."
  },
  {
    "objectID": "4-03-counting-more-systems.html#counting-kinds-of-storms",
    "href": "4-03-counting-more-systems.html#counting-kinds-of-storms",
    "title": "14  Counting More Systems",
    "section": "14.1 Counting Kinds of Storms",
    "text": "14.1 Counting Kinds of Storms\nRecall that tropical systems are classified into different categories depending on their wind speed. This classification is based on the famous Saffir-Simpson wind scale, given in the following table.\n\nTable: Saffir-Simpson scale\n\n\nCategory\nScale\nknots (kn)\nmph\n\n\n\n\nTropical Depression\n-1\n\\(<=\\) 33\n\\(<=\\) 38\n\n\nTropical Storm\n0\n34 - 63\n39 - 73\n\n\nHurricane category 1\n1\n64 - 82\n74 - 95\n\n\nHurricane category 2\n2\n83 - 95\n96 - 110\n\n\nHurricane category 3\n3\n96 - 112\n111 - 129\n\n\nHurricane category 4\n4\n113 - 136\n130 - 156\n\n\nHurricane category 5\n5\n\\(>=\\) 137\n\\(>=\\) 157\n\n\n\nHurricanes of categories 3, 4, and 5 are considered to be major hurricanes.\n\n14.1.1 Counting Tropical Depressions\nWe may start by getting the count of tropical depressions per year. Knowing that tropical depressions have winds no greater than 33 knots, we can filter() column wind for this numeric value.\n\n# trying to count tropical depressions per year\ndepression_counts_per_year = storms |> \n  filter(wind <= 33) |>\n  count(year, name) |>\n  count(year)\n\n# inspect a few rows\nhead(depression_counts_per_year)\n\n# A tibble: 6 × 2\n   year     n\n  <dbl> <int>\n1  1975     7\n2  1976     7\n3  1977     6\n4  1978    10\n5  1979     8\n6  1980    10\n\n\nAccording to this output, it seems that there were 2 tropical depressions in 1975, 2 in 1976, 3 in 1977, etc.\nWhat about the number of tropical storms? Well, to obtain this count we should filter wind values between 34 and 63 knots, and then compute the count():\n\n# trying to count tropical storms per year\nstorm_counts_per_year = storms |> \n  filter(wind >= 34 & wind < 64) |>\n  count(year, name) |>\n  count(year)\n\n# inspect a few rows\nhead(storm_counts_per_year)\n\n# A tibble: 6 × 2\n   year     n\n  <dbl> <int>\n1  1975     8\n2  1976     7\n3  1977     6\n4  1978    11\n5  1979     8\n6  1980    11\n\n\nBased on this output, it seems that there were 3 tropical storms in 1975, 2 in 1976, 3 in 1977, etc.\nBut wait … We know, from the preceding chapter, that the counts of systems per year are:\n\nsystem_counts_per_year <- storms |> \n  count(year, name) |> \n  count(year)\n\nhead(system_counts_per_year)\n\n# A tibble: 6 × 2\n   year     n\n  <dbl> <int>\n1  1975     8\n2  1976     7\n3  1977     6\n4  1978    11\n5  1979     8\n6  1980    11\n\n\nHow come is it that in 1975 there were two tropical depressions, and also two tropical storms, but a total of three systems?\nLikewise, how is it that in 1976 there were also two tropical depressions, and two tropical storms, but a total of only two systems?\nOkay, okay. You may know the answer to this apparent conundrum. The explanation for these seemingly contradictory results has to do with the life cycle of tropical systems. Technically speaking, they all start as baby storms or disturbances that can get bigger, eventually reaching tropical depression status, and under the right weather conditions, they can continue to grow reaching tropical storm category, or hurricane of category 1, or other bigger categories.\nI know that the above outputs and the interpretations I’m providing for them may seem a bit silly to (some of) you. Yes, I’m doing it on purpose: to walk you through the type of exploration, sanity checks, and questions that you should be asking yourself along the way when analyzing data. This is especially vital when you are working with a data set from some topic or field in which you don’t have much experience with.\n\n\n14.1.2 Counts Based on Maximum Wind Speed\nA more adequate approach for identifying tropical depressions consists of first obtaining the maximum wind speed of each system, and then filtering for values of 33 knots or less.\n\n# identifying tropical depressions\ndepressions = storms |>\n  group_by(year, name) |>\n  summarise(wind_max = max(wind), .groups = \"drop\") |>\n  filter(wind_max <= 33)\n\nslice_head(depressions, n = 10)\n\n# A tibble: 10 × 3\n    year name     wind_max\n   <dbl> <chr>       <int>\n 1  1991 AL041991       30\n 2  1991 AL101991       25\n 3  1992 AL021992       30\n 4  1992 AL031992       30\n 5  1992 AL081992       30\n 6  1993 AL101993       30\n 7  1994 AL021994       30\n 8  1994 AL051994       30\n 9  1994 AL081994       30\n10  1994 AL091994       30\n\n\nHaving obtained the data that exclusively contains tropical depressions, we can then count their number in each year:\n\n# counting tropical depressions per year\ndepression_counts_per_year = depressions |>\n  count(year)\n\nslice_head(depression_counts_per_year, n = 10)\n\n# A tibble: 10 × 2\n    year     n\n   <dbl> <int>\n 1  1991     2\n 2  1992     3\n 3  1993     1\n 4  1994     5\n 5  1995     2\n 6  1997     1\n 7  1999     4\n 8  2000     4\n 9  2001     2\n10  2002     2\n\n\n\n\n14.1.3 Counting Tropical Storms\nTropical storms are tropical systems with wind speeds between 39 mph and 73 mph or equivalently, between 34 and 63 knots. With this information, we proceed in the same way as in the above subsection: first we identify the set that exclusively contains tropical storms, and then we count them by year.\n\n# identifying tropical storms\ntrop_storms = storms |>\n  group_by(year, name) |>\n  summarise(wind_max = max(wind), .groups = \"drop\") |>\n  filter(wind_max >= 34 & wind_max < 64)\n\nslice_head(trop_storms, n = 10)\n\n# A tibble: 10 × 3\n    year name   wind_max\n   <dbl> <chr>     <int>\n 1  1975 Amy          60\n 2  1975 Hallie       45\n 3  1976 Dottie       45\n 4  1977 Frieda       50\n 5  1978 Amelia       45\n 6  1978 Bess         45\n 7  1978 Debra        50\n 8  1978 Hope         55\n 9  1978 Irma         45\n10  1978 Juliet       45\n\n\n\n# counting tropical storms per year\nstorm_counts_per_year = trop_storms |>\n  count(year)\n\nslice_head(storm_counts_per_year, n = 10)\n\n# A tibble: 10 × 2\n    year     n\n   <dbl> <int>\n 1  1975     2\n 2  1976     1\n 3  1977     1\n 4  1978     6\n 5  1979     3\n 6  1980     2\n 7  1981     4\n 8  1982     3\n 9  1983     1\n10  1984     7\n\n\nSo far, so good. Things seem to make sense, and we are making nice progress in our data exploration journey.\nBut before moving on with other counts, let’s do a quick sanity check (just in case). For example, we could take into consideration the column category. This column contains numeric codes for the different types of categories based on the Saffir-Simpson wind scale.\nTo be more precise: in addition to wind_max, let’s also include the maximum category value when identifying the set of tropical storms. If everything is correct, all the entries should have category value of 0 which is the numeric code for tropical storms.\n\n# identifying tropical storms\ntrop_storms = storms |>\n  filter(wind >= 34) |>\n  group_by(year, name) |>\n  summarise(wind_max = max(wind)) |>\n  filter(wind_max < 64)\n\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n\nslice_head(trop_storms, n = 10)\n\n# A tibble: 264 × 3\n# Groups:   year [47]\n    year name   wind_max\n   <dbl> <chr>     <int>\n 1  1975 Amy          60\n 2  1975 Hallie       45\n 3  1976 Dottie       45\n 4  1977 Frieda       50\n 5  1978 Amelia       45\n 6  1978 Bess         45\n 7  1978 Debra        50\n 8  1978 Hope         55\n 9  1978 Irma         45\n10  1978 Juliet       45\n# ℹ 254 more rows\n\n\n\n\n\nThis output only displays the first ten rows, but you are welcome to inspect the values in column name.\nDid you observe anything special? Was there anything that caught your attention?\nIf your answer is “No”, then go back to carefully inspect the content of trop_storms.\nIf your answer is “Yes”, because you noticed some weird storm names such as AL031987 or AL061988, then let me say to you: “good job!”\nIndeed, there seem to be a few tropical storms that don’t have a proper name. In theory, once a tropical system reaches tropical storm status, it receives a non-alphanumeric name such as Amy or Amelia or Bess. To detect all the entries in trop_storms that don’t have a proper name you can use the following command:\n\n# unnamed storms\ntrop_storms |>\n  filter(str_starts(name, pattern = \"A(l|L)\\\\d+\"))\n\n# A tibble: 5 × 3\n# Groups:   year [5]\n   year name     wind_max\n  <dbl> <chr>       <int>\n1  1987 AL031987       40\n2  1988 AL061988       50\n3  1993 AL011993       35\n4  2006 AL022006       45\n5  2011 Al202011       40\n\n\nAs you can tell, this command is a filtering operation. However, the code inside filter() is somewhat advanced. It uses the str_starts() function to match those names that start with either \"AL\" or \"Al\" and are followed by several digits.\nTo be honest, I’m not sure why we have these mismatched values. It could be that the category values for these systems are incorrect. Or it could be the opposite: the category is okay, but the problem is with the name values."
  },
  {
    "objectID": "4-04-counting-all-systems.html",
    "href": "4-04-counting-all-systems.html",
    "title": "15  Counting All Types of Systems",
    "section": "",
    "text": "So far we’ve found a satisfying way to count the number of tropical depressions as well as the number of tropical storms. We could adapt the recent commands to get a table with counts of hurricanes of category 1, another table for hurricanes of category 2, and so on and so forth.\nInterestingly, we can also identify the maximum category for each type of system, all at once. All we have to do is remove the filter() command, as follows:"
  },
  {
    "objectID": "4-04-counting-all-systems.html#handling-various-conditions",
    "href": "4-04-counting-all-systems.html#handling-various-conditions",
    "title": "15  Counting All Types of Systems",
    "section": "15.1 Handling Various Conditions",
    "text": "15.1 Handling Various Conditions\nWe can take a further step and add a column that displays the category status in text form.\nHow can you accomplish this? One nice option is with the case_when() function. Let’s take a look at the command that gets the job done, and then we discuss it.\n\n# adding a wind category status in text format\nsystem_status = storms |>\n  group_by(year, name) |>\n  summarise(\n    wind_max = max(wind), \n    .groups = \"drop\") |>\n  mutate(wind_scale = case_when(\n      wind_max <= 33 ~ -1L,\n      wind_max <= 63 ~ 0L,\n      wind_max <= 82 ~ 1L,\n      wind_max <= 95 ~ 2L,\n      wind_max <= 112 ~ 3L,\n      wind_max <= 136 ~ 4L,\n      wind_max >= 137 ~ 5L\n    )\n  )\n\nslice_head(system_status, n = 10)\n\n# A tibble: 10 × 4\n    year name     wind_max wind_scale\n   <dbl> <chr>       <int>      <int>\n 1  1975 Amy            60          0\n 2  1975 Blanche        75          1\n 3  1975 Caroline      100          3\n 4  1975 Doris          95          2\n 5  1975 Eloise        110          3\n 6  1975 Faye           90          2\n 7  1975 Gladys        120          4\n 8  1975 Hallie         45          0\n 9  1976 Belle         105          3\n10  1976 Candice        80          1\n\n\nTo describe how case_when() works, let’s pay attention to the part of the code that involves this command:\nwind_scale = case_when(\n  wind_max <= 33 ~ -1,\n  wind_max <= 63 ~ 0,\n  wind_max <= 82 ~ 1,\n  wind_max <= 95 ~ 2,\n  wind_max <= 112 ~ 3,\n  wind_max <= 136 ~ 4,\n  wind_max >= 137 ~ 5\n)\nAs you can tell, the input to case_when() consists of multiple conditions based on the variable wind_max. The first condition is:\nwind_max <= 33 ~ -1\nThis means that the value -1 will be associated to all the wind_max values less than or equal to 33. Basically, this indicates a tropical depression.\nThe next condition is:\nwind_max <= 63 ~ 0\nwhich means that 0 will be associated to all the wind_max values less than or equal to 63 (but greater than 33). This indicates a tropical storm.\nObserve also the use of the tilde ~ to indicate the output for each text value.\nWe can take a further step to add another column wind_categ that displays the category status in text form. That is, for wind_scale == -1 have an associated value of \"td\"; for wind_scale == 0 have an associated value of \"ts\"; for wind_scale == 1 have an associated value of \"cat1\", etc.\n\n# adding a wind category status in text format\nsystem_status = system_status |>\n  mutate(wind_categ = case_when(\n      wind_scale == -1 ~ 'td',\n      wind_scale == 0 ~ 'ts',\n      wind_scale == 1 ~ 'cat1',\n      wind_scale == 2 ~ 'cat2',\n      wind_scale == 3 ~ 'cat3',\n      wind_scale == 4 ~ 'cat4',\n      wind_scale == 5 ~ 'cat5'\n  ))\n\nslice_head(system_status, n = 10)\n\n# A tibble: 10 × 5\n    year name     wind_max wind_scale wind_categ\n   <dbl> <chr>       <int>      <int> <chr>     \n 1  1975 Amy            60          0 ts        \n 2  1975 Blanche        75          1 cat1      \n 3  1975 Caroline      100          3 cat3      \n 4  1975 Doris          95          2 cat2      \n 5  1975 Eloise        110          3 cat3      \n 6  1975 Faye           90          2 cat2      \n 7  1975 Gladys        120          4 cat4      \n 8  1975 Hallie         45          0 ts        \n 9  1976 Belle         105          3 cat3      \n10  1976 Candice        80          1 cat1      \n\n\nWith system_status we can then create a barchart, mapping wind_scale to the fill attribute of the geom_col():\n\nsystem_status |>\n  count(year, wind_scale) |>\nggplot() +\n  geom_col(aes(x = year, y = n, fill = factor(wind_scale))) +\n  labs(title = \"Number of Storms per Year, and Category\",\n       y = \"Count\") +\n  theme_minimal()\n\n\n\n\nThis barchart allows us to see how different storm categories are distributed over time. As we know from the graphics obtained in chapter 13, the number of systems shows an increasing trend. Despite the eye catching color palette, and the clear increasing pattern, it is hard to tell whether all the storm categories exhibit the growing trend.\nAn alternative visual display is to use facets so that we separate each category in its own frame (see below).\n\nsystem_status |>\n  count(year, wind_scale) |>\nggplot() +\n  geom_col(aes(x = year, y = n, fill = factor(wind_scale))) +\n  facet_wrap(~ wind_scale) +\n  labs(title = \"Number of Storms Over Time, and Category\",\n       subtitle = \"Tropical storms have increased in the last 4 decades\",\n       y = \"Count\") +\n  theme_minimal() +\n  theme(panel.grid.minor = element_blank())\n\n\n\n\nIn this plot we can easily see that the main type of systems that have been constantly increasing every decade are tropical storms (category 0). This pattern was not so evident in the preceding graphic that does not have facets. If you look at hurricanes of category 3, their number seems to remain stable between 0 and 2 almost every year.\nOne last step: what happens if we specify wind_scale as an ordinal factor? Since the numeric scaled in wind_scale is an ordinal scale, we can take advantage of R’s factors and make this column an ordered factor via the function ordered(). The visual benefit of doing this is that ggplot() will use a special color palette called viridis which relies on a sequence of blues and yellows, while avoiding reds, in order to increase the readability of data visualizations.\n\nsystem_status = system_status |>\n  mutate(wind_scale = ordered(wind_scale))\n\nsystem_status |>\n  count(year, wind_scale) |>\nggplot() +\n  geom_col(aes(x = year, y = n, fill = wind_scale)) +\n  facet_wrap(~ wind_scale) +\n  labs(title = \"Number of Storms Over Time, and Category\",\n       subtitle = \"Tropical storms have increased in the last 4 decades\",\n       y = \"Count\") +\n  theme_minimal() +\n  theme(panel.grid.minor = element_blank())"
  },
  {
    "objectID": "5-01-maps-intro.html",
    "href": "5-01-maps-intro.html",
    "title": "16  Introduction to Maps",
    "section": "",
    "text": "In the previous chapters, you were introduced to the basics of \"dplyr\" and \"ggplot2\", which we then used to perform various operations on the data storms to obtain a wide array of visualizations as well as derived tables and summary statistics. Because storms contains geographical information such as longitude and latitude, in this part we take a further step to learn about plotting basic, and not so basic, maps with \"ggplot2\" as well as with some dedicated packages to create maps in R."
  },
  {
    "objectID": "5-01-maps-intro.html#some-words-about-maps-in-r",
    "href": "5-01-maps-intro.html#some-words-about-maps-in-r",
    "title": "16  Introduction to Maps",
    "section": "16.1 Some Words about Maps in R",
    "text": "16.1 Some Words about Maps in R\nKeep in mind that there is a wide array of packages for graphing all sorts of maps, and geospatial information. Good resources to look at are:\n\nDrawing beautiful maps programmatically with R, sf and ggplot2 by Mel Moreno and Mathieu Basille; https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html\nGeocomputation with R by Robin Lovelace, Jakub Nowosad, and Jannes Muenchow; https://r.geocompx.org/t\nMaking Maps with R by Eric C. Anderson; https://eriqande.github.io/rep-res-web/lectures/making-maps-with-R.html\n\nFrom: Geocomputation with R\n“There are many ways to handle geographic data in R, with dozens of packages in the area.”\nR’s spatial ecosystem has evolved and keeps evolving at a fast pace.\nAn inflection point in the development of R’s geospatial tools was the project Simple Features, an open-source standard and model to store and access vector geometries. This resulted in the sf package\nI’m going to focus on the following packages. Please keep in mind that the packages listed below are by no means a comprehensive set of tools for making maps in R.\n\nsf: Simple Features provides classes and functions for vector data\ntmap: Thematic Maps for static and interactive maps\nleaflet: for interactive maps\nmaps: maps data sets\nrnaturalearth: maps data sets\n\nAs Lovelace, Nowosad and Muenchow state: “The vector data model represents the world using points, lines and polygons. These have discrete, well-defined borders, meaning that vector datasets usually have a high level of precision. The raster data model divides the surface up into cells of constant size. Raster datasets are the basis of background images used in web-mapping and have been a vital source of geographic data since the origins of aerial photography and satellite-based remote sensing devices.”\nFrom Lovelace, Nowosad and Muenchow: reasons for using sf:\n\nFast reading and writing of data\nEnhanced plotting performance\nsf objects can be treated as data frames in most operations\nsf function names are relatively consistent and intuitive (all begin with st_)\nsf functions can be combined with the |> operator and works well with the tidyverse collection of R packages."
  },
  {
    "objectID": "5-02-maps-1975.html",
    "href": "5-02-maps-1975.html",
    "title": "17  Basic Maps",
    "section": "",
    "text": "In this chapter you will need the following packages:\nand the following objects:"
  },
  {
    "objectID": "5-02-maps-1975.html#graphing-maps",
    "href": "5-02-maps-1975.html#graphing-maps",
    "title": "17  Basic Maps",
    "section": "17.1 Graphing Maps",
    "text": "17.1 Graphing Maps\nIn this part, I provide a basic exposure to plotting maps with \"ggplot2\" and \"maps\".\n\n\n\n\n\n\nWarning\n\n\n\nI should say that the mapping approach described in this chapter is fairly limited, and it does not produce high-quality maps.\nThe only reason for why I’m including this approach is for legacy purposes: it is likely that you may find maps obtained with this basic combo of \"ggplot2\" and \"maps\".\nNowadays, it is better to use \"ggplot2\", \"sf\", and \"rnaturalearth\" as described in the next chapter.\n\n\n\n17.1.1 Plotting location of storm records\nFor illustration purposes, we continue using the data frame storms75. Having latitude and longitude, we can make a scatter plot to see the location of the storm records. Recall that the ggplot function to do this is geom_point(). To distinguish each storm, we can color the dots by taking into account the different storm names. This involves mapping the column name to the color attribute:\n\nggplot(data = storms75, aes(x = long, y = lat, color = name)) + \n  geom_point() +\n  labs(title = \"Location of Tropical Cyclones in North Atlantic\",\n       subtitle = \"1975 Season\")\n\n\n\n\n\n\n\n\nKeep in mind that the previous command can also be written as:\n\n# alternative ways to write equivalent commands\nggplot(data = storms75) +  \n  geom_point(aes(x = long, y = lat, color = name)) +\n  labs(title = \"Location of Tropical Cyclones in North Atlantic\",\n       subtitle = \"1975 Season\")\n\n# similarly\nggplot() +  \n  geom_point(data = storms75, aes(x = long, y = lat, color = name)) +\n  labs(title = \"Location of Tropical Cyclones in North Atlantic\",\n       subtitle = \"1975 Season\")\n\nThe above scatter plot is a good starting point to visualize the location of the storm records, but it would be nice to have an actual image of a map. Let’s see how to do this in the following subsections.\n\n\n17.1.2 Basic World Map\nOne of the oldest ways to plot maps in R is with the package \"maps\". This package comes with various functions that allow you to create maps, without the need to use \"ggplot2\" or any other tidyverse tool. \"maps\"also contains data sets of maps that can be used by \"ggplot2\" to visualize geospatial data.\nIn order to use ggplot() with one of the data sets in \"maps\", the first step involves creating a data frame via the function map_data(). This function turns data from the \"maps\" package into a table suitable for plotting with \"ggplot2\". For instance, to graph a map of the world—based on the \"world\" map—we first create a data frame:\n\n# world map data\nworld_map <- map_data(\"world\")\n\nclass(world_map)\n\n[1] \"data.frame\"\n\n\nOnce we have this data, we can use it with ggplot() and a geom_polygon() layer like this:\n\n# a default world map\nggplot() + \n  geom_polygon(data = world_map, \n               aes(x = long, y = lat, group = group))\n\n\n\n\n\n\n\n\nIn the above command, notice how we specify the data argument inside geom_polygon() instead of inside ggplot(). We do this because the data frame world_map is used to graph the layer of the map. We still need to add another layer—via geom_point()—for the coordinates indicating the positions of each storm.\nTo handle the code more easily, let’s modify the map, and create a \"ggplot\" object called gg_world. We’ll use this object as our “canvas” for plotting the storm locations:\n\n# map \"canvas\" stored as gg_world\ngg_world <- ggplot() + \n  geom_polygon(data = world_map, \n               aes(x = long, y = lat, group = group), \n               fill = \"gray95\", colour = \"gray70\", linewidth = 0.2) +\n  theme_bw()\n\ngg_world\n\n\n\n\n\n\n\n\n\n\n17.1.3 Mapping 1975 Storms\nNow that we know how to plot a map with ggplot(), we can add the points of the storm records. This is done with geom_point(), and specifying storms75 as the data argument inside this function. In other words, we are using two separate data frames. One is world_map to draw the polygons of the map; the other one is stomrs75 to graph the dots of each storm. Notice also that there are no inputs provided to the function ggplot().\n\n# world map, adding storms in 1975\ngg_world +\n  geom_point(data = storms75,\n             aes(x = long, y = lat, color = name))\n\n\n\n\n\n\n\n\nBecause the analyzed hurricanes occurred in the North Atlantic basin, we can focus on that region by modifying the x-and-y axis limits:\n\n# zoom-in\ngg_world +\n  geom_point(data = storms75,\n             aes(x = long, y = lat, color = name)) +\n  xlim(c(-150, 0)) + \n  ylim(c(0, 90))\n\n\n\n\n\n\n\n\nIt’s worth mentioning that this zoom-in has a secondary effect of distorting some of the polygons. For example, Alaska seems to get cut in half. Also the polygon of Colombia is incomplete. Ignoring these distortions for now, we can continue exploring things by taking into account more variables. For instance, let’s map the wind speed to the size argument of points.\n\ngg_world +\n  geom_point(data = storms75,\n             aes(x = long, y = lat, color = name, size = wind),\n             alpha = 0.5) +\n  xlim(c(-150, 0)) + \n  ylim(c(0, 90))\n\n\n\n\n\n\n\n\nA very similar appearance can be achieved by replacing geom_point() with geom_path():\n\ngg_world +\n  geom_path(data = storms75,\n             aes(x = long, y = lat, color = name, linewidth = wind),\n             lineend = \"round\", alpha = 0.4) +\n  xlim(c(-150, 0)) + \n  ylim(c(0, 90))"
  },
  {
    "objectID": "5-03-maps-sf.html",
    "href": "5-03-maps-sf.html",
    "title": "18  Simple Features Maps",
    "section": "",
    "text": "In the preceding chapter we described a fairly basic way to make maps of storms with packages \"maps\" and \"ggplot2\". While this approach may let us get the job done for simple maps, one of its main limitations has to do with the distortions caused when zooming-in to certain areas of a given map.\nA better approach to make maps of storm locations with \"ggplot2\" is to use it jointly with the packages \"sf\" (simple features) and \"rnaturalearth\". Instead of using map datasets from \"maps\" we are going to use maps from \"rnaturalearth\". And instead of using the geom_polygon() layer, we are going to use the geom_sf() layer.\nThe code in this chapter requires the following packages:\nand the following table for storms in 1975:"
  },
  {
    "objectID": "5-03-maps-sf.html#basic-world-map",
    "href": "5-03-maps-sf.html#basic-world-map",
    "title": "18  Simple Features Maps",
    "section": "18.1 Basic World Map",
    "text": "18.1 Basic World Map\nLike we did it in the previous chapter, let’s start with a basic world map. \"rnaturalearth\" provides a couple of world maps:\n\nworld coastline map, returned by ne_coastline()\nworld country polygons, returned by ne_countries()\n\n\n18.1.1 World Coastline Map\nOne very simple world map involves the coastline map. As mentioned above, this map is returned by the ne_coastline() function. In the following command, we specify a medium scale resolution, and a returned object of class \"sf\".\n\n# natural earth world coastline\nworld_coast = ne_coastline(scale = \"medium\", returnclass = \"sf\")\n\nclass(world_coast)\n\n[1] \"sf\"         \"data.frame\"\n\n\nBecause we are going use the geom_sf() layer, it is important to specify the argument returnclass = \"sf\" so that we obtain an object of class \"sf\". This kind of object is a simple features object, but it’s also a data frame suitable for ggplot().\nWe pass world_coast to ggplot(), and use geom_sf() which is the function that allows us to visualize the polygons of simple features objects \"sf\".\n\nggplot(data = world_coast) +\n  geom_sf()\n\n\n\n\n\n\n\n\n\n\n18.1.2 World Countries Map\nAnother world map involves the countries map. The data for this map is returned by ne_countries(). Like in the previous example, make sure you set the argument returnclass = \"sf\" to get a simple features tabular object that is also a data.frame:\n\n# natural earth world country polygons\nworld_countries = ne_countries(returnclass = \"sf\")\n\nggplot(data = world_countries) +\n  geom_sf()\n\n\n\n\n\n\n\n\nWhen making maps with ggplot() I like to modify the background to obtain simpler and cleaner visualizations. One option to do this is with the theme() function:\n\nggplot(data = world_countries) +\n  geom_sf() +\n  theme(panel.background = element_blank())\n\n\n\n\n\n\n\n\nOne of the nice aspects of \"rnaturalearth\" maps is that we can zoom-in without having distorted polygons. To focus on a specific region, we set the x-axis and y-axis limits with the coord_sf() function, for example:\n\nggplot(data = world_countries) +\n  geom_sf() +\n  coord_sf(xlim = c(-110, 0), ylim = c(5, 65)) +\n  theme(panel.background = element_blank())\n\n\n\n\n\n\n\n\n\n\n18.1.3 North America Map\nSimilarly, the ne_countries() function lets you obtain polygons data for a certain continent of the world: e.g. \"Europe\", \"Africa\", \"Asia\", \"North America\", \"South America\", \"Oceania\", etc.\n\n# natural earth world country polygons in North America\nnorth_america = ne_countries(continent = \"North America\", returnclass = \"sf\")\n\nggplot(data = north_america) +\n  geom_sf() +\n  theme(panel.background = element_blank())"
  },
  {
    "objectID": "5-03-maps-sf.html#plotting-storms",
    "href": "5-03-maps-sf.html#plotting-storms",
    "title": "18  Simple Features Maps",
    "section": "18.2 Plotting Storms",
    "text": "18.2 Plotting Storms\nNow that we know how to get polygons from natural earth, and how to plot them—via ggplot()—with geom_sf() and coord_sf(), let’s add the longitude and latitude locations of storms in 1975.\nBecause the storm locations come from the tibble storms75, we pass this data to geom_point()\n\nggplot(data = north_america) +\n  geom_sf() +\n  geom_point(data = storms75,\n             aes(x = long, y = lat, group = name)) +\n  theme(panel.background = element_blank()) \n\n\n\n\n\n\n\n\nInstead of points, we can connect the locations with lines through geom_path()\n\nggplot(data = north_america) +\n  geom_sf() +\n  geom_path(data = storms75,\n             aes(x = long, y = lat, group = name)) +\n  theme(panel.background = element_blank()) \n\n\n\n\n\n\n\n\nAnd then enhance it with colors mapping the name column to the color aesthetic of geom_path():\n\nggplot(data = north_america) +\n  geom_sf() +\n  geom_path(data = storms75,\n            aes(x = long, y = lat, group = name, color = name)) +\n  theme(panel.background = element_blank()) \n\n\n\n\n\n\n\n\n\nInteractive map with ggplotly()\nFor your amusement, you can take a ggplot object and pass it to ggplotly() in order to get an interactive map:\n\ngg = ggplot(data = north_america) +\n  geom_sf() +\n  geom_path(data = storms75,\n             aes(x = long, y = lat, group = name, color = name)) +\n  theme(panel.background = element_blank())\n\nggplotly(gg)"
  },
  {
    "objectID": "5-03-maps-sf.html#hurricanes-in-1975",
    "href": "5-03-maps-sf.html#hurricanes-in-1975",
    "title": "18  Simple Features Maps",
    "section": "18.3 Hurricanes in 1975",
    "text": "18.3 Hurricanes in 1975\nHurricanes in 1975\n\n# vector of hurricane names\nhurr_names75 <- storms75 |>\n  filter(wind >= 64) |>\n  distinct(name) |>\n  pull(name)\n\nhurr_names75\n\n[1] \"Blanche\"  \"Caroline\" \"Doris\"    \"Eloise\"   \"Faye\"     \"Gladys\"  \n\n\nWe can then filter hurricanes:\n\nhurricanes75 <- storms75 |>\n  filter(name %in% hurr_names75)\n\nWe’ll use hurricanes75 to super impose their longitude and latitude coordinates onto the world_countries map:\n\nggplot(data = world_countries) +\n  geom_sf() +\n  geom_path(\n    data = hurricanes75, \n    aes(x = long, y = lat, group = name, color = name, linewidth = wind), \n    lineend = \"round\", alpha = 0.6) + \n  coord_sf(xlim = c(-110, 0), ylim = c(5, 65), expand = FALSE) +\n  theme(panel.background = element_blank()) +\n  labs(title = \"Hurricanes in 1975\")\n\n\n\n\n\n\n\n\nA slightly more curated map\n\nggplot(data = world_countries) +\n  geom_sf(fill = \"#FFFBED\") +\n  geom_path(\n    data = hurricanes75, \n    aes(x = long, y = lat, group = name, color = name, linewidth = wind), \n    lineend = \"round\", alpha = 0.6) + \n  coord_sf(xlim = c(-110, 0), ylim = c(5, 65), expand = FALSE) +\n  theme(panel.background = element_rect(fill = \"aliceblue\")) +\n  labs(title = \"North Atlantic Hurricanes\", \n       subtitle = \"Season 1975\")"
  },
  {
    "objectID": "5-03-maps-sf.html#more-maps",
    "href": "5-03-maps-sf.html#more-maps",
    "title": "18  Simple Features Maps",
    "section": "18.4 More Maps",
    "text": "18.4 More Maps\nAs a simple experiment, let’s graph storms between 1975 and 1980 (six years). First we create a dedicated data table storms_set to select the rows we are interested in:\n\n# 2nd map (coloring storms individually)\nwhich_years = 1975:1980\n\n# Subset storms (for a given year)\nstorms_set = storms |>\n  filter(year %in% which_years)\n\nAnd then we can use facet_wrap(~ year) to graph storms by year:\n\nggplot(data = world_countries) +\n  geom_sf() +\n  coord_sf(xlim = c(-110, 0), ylim = c(5, 65), expand = FALSE) +\n  geom_path(data = storms_set,\n             aes(x = long, y = lat, group = name),\n             lineend = \"round\") +\n  theme(panel.background = element_blank()) +\n  facet_wrap(~ year) +\n  labs(title = \"Storms in North Atlantic, 1975-1980\")"
  },
  {
    "objectID": "5-04-maps-leaflet.html",
    "href": "5-04-maps-leaflet.html",
    "title": "19  Leaflet Maps",
    "section": "",
    "text": "Another interesting approach to make maps is based on the R package \"leaflet\".\nThe code in this chapter requires the following packages:\nand the following table for storms in 1975:"
  },
  {
    "objectID": "5-04-maps-leaflet.html#introduction",
    "href": "5-04-maps-leaflet.html#introduction",
    "title": "19  Leaflet Maps",
    "section": "19.1 Introduction",
    "text": "19.1 Introduction\nLeaflet is one of the most popular open-source JavaScript libraries for web-based interactive maps. The good news for R users is that we also have the homonym R package \"leaflet\" that allows us to create maps directly from the R console, from RStudio, in Shiny applications, and in source dynamic documents that produce HTML output (e.g. Rmd, qmd files).\nExtensive documentation for \"leaflet\" can be found in RStudio’s Leaflet for R: https://rstudio.github.io/leaflet/basemaps.html\n\n19.1.1 Basic World Map\nIn analogous way to what we’ve done in the last two chapters, let’s start with a basic map of the world. With \"leaflet\" this is straightforward and it is actually the default map produced by the main function leaflet() with the layer addTiles()\n\nleaflet() |>\n  addTiles()\n\n\n\n\n\n\nAs you can tell, the way you create a Leaflet map requires 2 basic steps:\n\nCreate a map widget by calling leaflet().\nAdd layers (i.e., features) to the map by using layer functions—e.g.  addTiles(), addMarkers(), addPolygons()—to modify the map widget.\n\nThe displayed map is an HTML web-based interactive map. Notice that, by default, addTiles() uses a map from OpenStreetMap which is a free, open geographic database that provides geospatial data for anyone to use and share.\n\n\n19.1.2 Zooming\nWe can zoom in to a certain location of the World by adding another layer function: setView() with arguments lng and lat for the desired location, and a zoom value. For example, we can get a map centered in Miami, Florida:\n\n# view centered at Miami, FL\n# value \"zoom = 3\" found by trail and error\nleaflet() |>\n  addTiles() |>\n  setView(lng = -80.19, lat = 25.76, zoom = 3)\n\n\n\n\n\n\nSince we are using Miami, FL as the point of reference to center our map, we can also use an addMarkers() layer with the same set of coordinates to include a map marker that you can click on and see the text displayed in the argument popup:\n\n# view centered at Miami, FL\nleaflet() |>\n  addTiles() |>\n  setView(lng = -80.19, lat = 25.76, zoom = 3) |>\n  addMarkers(lng = -80.19, lat = 25.76, popup=\"Miami\")\n\n\n\n\n\n\n\n\n19.1.3 Provider Tiles\nIf you prefer, you can set the view to a different set of coordinates so that the map is somewhat centered in the middle of the North Atlantic ocean. In addition, you can use addProviderTiles() to change the tile from other map providers. Here’s an example with provider \"CartoDB\"\n\n# zoom-in in the middle of North Atlantic ocean\nleaflet() |>\n  setView(lng = -50, lat = 30, zoom = 3) |>\n  addTiles() |>\n  addProviderTiles(provider = \"CartoDB\")\n\n\n\n\n\n\nAnd here’s another example with one of my favorite tile providers, \"NASAGIBS.ViirsEarthAtNight2012\", which gives you a night view of the Earth:\n\n# zoom-in in the middle of North Atlantic ocean\nleaflet() |>\n  setView(lng = -50, lat = 30, zoom = 3) |>\n  addTiles() |>\n  addProviderTiles(provider = \"NASAGIBS.ViirsEarthAtNight2012\")\n\n\n\n\n\n\nTo summarize, the creation of Leaflet maps involve the following steps:\n\nstart with leaflet().\nAdd layers with functions such as addTiles(), addMarkers(), addPolygons(), etc to modify the map widget.\nRepeat step 2 as desired.\nPrint the map widget to display it."
  },
  {
    "objectID": "5-04-maps-leaflet.html#plotting-storms",
    "href": "5-04-maps-leaflet.html#plotting-storms",
    "title": "19  Leaflet Maps",
    "section": "19.2 Plotting Storms",
    "text": "19.2 Plotting Storms\nHow do we add the position of storms? Simple: by forming a pipeline where we pipe storms to leaflet(), and adding circle markers with addCircleMarkers() (the equivalent of geom_point() in \"ggplot2\")\nConsider all tropical cyclones back in 1975\nFirst map centered in Miami, Florida\n\n# all tropycal cyclones in 1975\nstorms75 |>\n  leaflet() |>\n  setView(lng = -50, lat = 30, zoom = 2) |>\n  addProviderTiles(provider = 'CartoDB') |>\n  addCircleMarkers(\n    lng = ~long, \n    lat = ~lat,\n    radius = 1)\n\n\n\n\n\n\nWhat if we just want to plot the hurricanes? First we get their names, stored in a character vector:\n\n# vector of hurricane names\nhurr_names75 <- storms75 |>\n  filter(wind >= 64) |>\n  distinct(name) |>\n  pull(name)\n\nhurr_names75\n\n[1] \"Blanche\"  \"Caroline\" \"Doris\"    \"Eloise\"   \"Faye\"     \"Gladys\"  \n\n\nWe can then filter hurricanes:\n\nhurricanes75 <- storms75 |>\n  filter(name %in% hurr_names75)\n\nAnd then we pass them to leaflet()\n\n# all hurricanes in 1975\nhurricanes75 |>\n  leaflet() |>\n  setView(lng = -50, lat = 30, zoom = 2) |>\n  addProviderTiles(provider = 'CartoDB') |>\n  addCircleMarkers(\n    lng = ~long, \n    lat = ~lat,\n    radius = 1)\n\n\n\n\n\n\n\n19.2.1 Customizing color palette\nAs we did with ggplot(), we can also color the storms in order to distinguish them:\n\n# If you want to set your own colors manually:\ncount_storms75 = storms75 |>\n  distinct(name) |>\n  nrow()\n\npal <- colorFactor(\n  palette = rainbow(n = count_storms75),\n  domain = storms75$name\n)\n\n\nstorms75 |>\n  leaflet() |>\n  addProviderTiles('CartoDB') |>\n  setView(lng = -80.19, lat = 25.76, zoom = 3) |>\n  addCircleMarkers(\n    lng = ~long, \n    lat = ~lat,\n    radius = 2, \n    color = ~pal(name))\n\n\n\n\n\n\n\n\n19.2.2 Adding a Legend\nTo add a legend, we need to use the function addLegened():\n\ncolores <- rainbow(n = count_storms75)\n\n\nstorms75 |>\n  leaflet() |>\n  addProviderTiles('CartoDB') |>\n  setView(lng = -80.19, lat = 25.76, zoom = 3) |>\n  addCircleMarkers(\n    lng = ~long, \n    lat = ~lat,\n    radius = 2, \n    color = ~pal(name)) |>\n  addLegend(\n    position = \"bottomleft\",\n    color = ~colores,\n    labels = ~unique(storms75$name),\n    title = \"Storms in 1975\",\n    opacity = 1,\n    group = \"circles\"\n  )"
  },
  {
    "objectID": "5-05-maps-tmap.html",
    "href": "5-05-maps-tmap.html",
    "title": "20  Thematic Maps",
    "section": "",
    "text": "So far we’ve seen how to create maps with three approaches:\nIn this chapter we describe a third approach to make maps with R packages \"sf\" and \"tmap\" (no \"ggplot2\"). This is yet another map-making approach that is similar to those listed above. One of the main differences is that thematic maps don’t rely on \"ggplot2\", instead \"tmap\" relies on its own grammar of graphics.\nThe code in this chapter requires the following packages:"
  },
  {
    "objectID": "5-05-maps-tmap.html#basic-world-map",
    "href": "5-05-maps-tmap.html#basic-world-map",
    "title": "20  Thematic Maps",
    "section": "20.1 Basic World Map",
    "text": "20.1 Basic World Map\n\n# World map (from \"tmap\")\ndata(\"World\")\n\ntm_shape(World) +\n  tm_polygons()\n\n\n\n\ntm_layout() is used to specify elements that have to do with the map layout such as the background color, for example:\n\ntm_shape(World) +\n  tm_polygons(col = \"gray90\") +\n  tm_layout(bg.color = \"lightblue1\")\n\n\n\n\n\n20.1.1 tmaps with sf objects\nWe can also work with map objects of class \"sf\" (simple features), which means we can take advantage of maps available in \"rnaturalearth\"\n\n# natural earth world country polygons\nnorth_america = ne_countries(continent = \"north america\", returnclass = \"sf\")\n\ntm_shape(north_america) +\n  tm_borders()\n\n\n\n\n\ntm_shape(north_america) +\n  tm_polygons()"
  },
  {
    "objectID": "5-05-maps-tmap.html#adding-storms-in-2010",
    "href": "5-05-maps-tmap.html#adding-storms-in-2010",
    "title": "20  Thematic Maps",
    "section": "20.2 Adding Storms in 2010",
    "text": "20.2 Adding Storms in 2010\n\n# 2nd map (coloring storms individually)\nwhich_year = 2010\n\n# Subset storms (for a given year)\nstorms_set = storms |>\n  filter(year == which_year)\n\n# convert to \"sf\" object\nstorms_set_sf = st_as_sf(storms_set, coords = c(\"long\", \"lat\"))\n\nNow we can plot it:\n\ntm_shape(north_america) +\n  tm_polygons(col = \"gray95\") + \n  tm_shape(storms_set_sf) +\n  tm_dots(col = \"name\", size = 0.1)\n\nWarning: Currect projection of shape storms_set_sf unknown. Long-lat (WGS84) is\nassumed."
  },
  {
    "objectID": "5-05-maps-tmap.html#adding-hurricanes-in-2010",
    "href": "5-05-maps-tmap.html#adding-hurricanes-in-2010",
    "title": "20  Thematic Maps",
    "section": "20.3 Adding Hurricanes in 2010",
    "text": "20.3 Adding Hurricanes in 2010\nCoordinate Reference Systems (CRS) provide a standardized way of describing locations. Many different CRS are used to describe geographic data. In R, when data with different CRS are combined it is important to transform them to a common CRS so they align with one another.\nA particular CRS can be referenced by its EPSG code (e.g. EPSG: 4326).\nIn order to use the longitude and latitude coordinates of storms with tmap functions, we have to create a simple features object, and also specify the CRS to be used. In this case, we use the standard EPSG: 4326.\nThe Latitude and Longitude coordinates for a particular location will differ depending on the CRS and when the measurement was taken. Below we use WGS84 (EPSG: 4326)\n\n# 2nd map (coloring storms individually)\nwhich_year = 2010\n\n# Subset storms (for a given year)\nhurricanes_set = storms |>\n  filter(year == which_year & wind >= 64)\n\n# convert to \"sf\" object\nhurricanes_set_sf = st_as_sf(\n  hurricanes_set, \n  coords = c(\"long\", \"lat\"),\n  crs = 4326)\n\nNow we can plot it:\n\ntm_shape(north_america) +\n  tm_polygons(col = \"gray95\") + \n  tm_shape(hurricanes_set_sf) +\n  tm_dots(col = \"name\", size = 0.2)"
  },
  {
    "objectID": "5-05-maps-tmap.html#interactive-map",
    "href": "5-05-maps-tmap.html#interactive-map",
    "title": "20  Thematic Maps",
    "section": "20.4 Interactive Map",
    "text": "20.4 Interactive Map\n\ntmap_mode(\"view\")\n\ntmap mode set to interactive viewing\n\ntm_shape(north_america) +\n  tm_borders() + \n  tm_shape(hurricanes_set_sf) +\n  tm_dots(col = \"name\")"
  }
]