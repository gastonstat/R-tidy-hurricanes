[["index.html", "Tidy Hurricanes Analyzing Tropical Storms with Tidyverse Tools About", " Tidy Hurricanes Analyzing Tropical Storms with Tidyverse Tools Gaston Sanchez About The goal of this text is to help you get started working with tabular data using the syntactic approach of so-called Tidyverse tools. More specifically, we describe various examples for how to use functions from Tidyverse packages to perform common operations around data tables by analyzing storms and hurricanes in the North Atlantic. About You I am assuming that you have both R or RStudio installed in your computer. If this is not the case, you can take a look at Breaking the Ice with R https://www.gastonsanchez.com/R-ice-breaker Citation You can cite this work as: Sanchez, G. (2022) Analyzing Tropical Storms with Tidyverse Tools. https://www.gastonsanchez.com/R-tidy-hurricanes My Series of R Tutorials This manuscript is part of a series of texts that I’ve written about Programming and Data Analysis in R: Breaking the Ice with R: Getting Started with R and RStudio https://www.gastonsanchez.com/R-ice-breaker Tidy Hurricanes: Analyzing Tropical Storms with Tidyverse Tools https://www.gastonsanchez.com/R-tidy-hurricanes R Coding Basics: An Introduction to the Basics of Coding in R https://www.gastonsanchez.com/R-coding-basics Rolling Dice: Exploring Simulations in Games of Chance with R https://www.gastonsanchez.com/R-rolling-dice Web Technologies in R: A Short Introduction to Web Technologies in R https://www.gastonsanchez.com/R-web-technologies Donation As a Data Science and Statistics educator, I love to share the work I do. Each month I spend dozens of hours curating learning materials like this resource. If you find any value and usefulness in it, please consider making a one-time donation—via paypal—in any amount (e.g. the amount you would spend inviting me a cup of coffee or any other drink). Your support really matters. License This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["tables-and-tidyverse.html", "1 Tables and Tidyverse", " 1 Tables and Tidyverse The main dish in this text has to do with working with tabular data (i.e. data arranged in rows and columns). The main reason to focus on tables is because tabular data is the most ubiquitous format in which data is handled for most types of analysis. Hey, what if my data is not in tabular format? While it is true that not all data sets are stored or organized in tables, in most data analysis projects—sooner or later—you will be handling data in some sort of rectangular structure. Because of this, I firmly believe that the best way to get you started learning about data analysis with R is by getting your hands dirty manipulating tables. Obviously there are limitations. Not everything that is done in data analysis can be done with tables. But having a solid foundation around data arranged in this format will pay off down your data analysis road. Installing Tidyverse Since this text focuses on Tidyverse tools, you will need to install the associated ecosystem of Tidyverse packages. This is very easy to do. Recall that there are a couple of different ways to install R packages. One common option is to invoke the install.packages() function in R’s console, specifying the name(s) of the package(s), within quotations, and separated by commas, to be installed. Like this: # don&#39;t include this command in any Rmd file # don&#39;t worry too much if you get a warning message install.packages(&quot;tidyverse&quot;) Another option to install a package in RStudio is to do it by using the Packages tab located in the pane that contains other tabs such as Files, Plots, Help, etc. In the Packages tab you can find the “Install” button, click it, and follow the steps to install \"tidyverse\". Remember that you only need to install a package once! After a package has been installed in your machine, there is no need to call install.packages() again on the same package. What you should always invoke, in order to use the functions in a package, is the library() function: # you should include this command in your source file(s) library(tidyverse) About loading packages: Another rule to keep in mind is to always load any required packages at the very top of your script files (e.g. .R or .Rmd or .qmd or .Rnw files). Avoid calling the library() function in the middle of a script. Instead, load all the packages before anything else. A bit about Tidyverse Tidyverse is not a single package. Instead, it is a collection of packages. This means that when you install \"tidyverse\", you are actually installing the following packages \"ggplot2\": for creating plots and graphics \"dplyr\": for manipulating tables \"tidyr\": to tidying-up your data \"readr\": for importing rectangular data \"tibble\": provides “improved” R data frames \"stringr\": for string manipulation \"forcats\": for working with R factors \"purrr\": for functional programming in R To learn more about other tidyverse details, visit: https://tidyverse.tidyverse.org/ Note We won’t cover all the functionality provided by Tidyverse. Instead, we will focus on \"dplyr\" and \"ggplot2\". "],["tropical-storms.html", "2 Tropical Storms and Hurricanes 2.1 A little bit about Hurricanes", " 2 Tropical Storms and Hurricanes Figure 2.1: NASA satellite image of hurricane Sandy, 2012 (source: wikimedia commons) “Hurricane Sandy (unofficially referred to as Superstorm Sandy) was the deadliest and most destructive, as well as the strongest, hurricane of the 2012 Atlantic hurricane season. Inflicting nearly $70 billion (2012 USD) in damage, it was the second-costliest hurricane on record in the United States until surpassed by Hurricanes Harvey and Maria in 2017. Source: https://en.wikipedia.org/wiki/Hurricane_Sandy 2.1 A little bit about Hurricanes I don’t remember very well when was the first time I got curious about Hurricanes. I did not grew up in hurricane country or anywhere near regions prone to be hit by this kind of storms. However, I do remember learning about clouds, meteorology, and how storms form over mountain ranges. I learned this when I was in my early 20s taking my first steps into the mountaineering world. Experiencing the force and dangers of several storms in the mountains and volcanoes of my homeland, sparked in me a general interest to know more about this type of weather phenomena. It is said that the word hurricane is derived from the Spanish word huracán which in turn comes from the Taino word hurakán, that was used by the indigenous people of the Caribbean and Central America to designate the “god of wind” or the “evil spirits of the wind”. Nowadays, the word hurricane is informally used to denote low-pressure systems with organized thunderstorm activity that form over tropical or subtropical waters. Among weather experts, though, the term hurricane is reserved for a specific class of tropical systems: those that reach wind speeds of at least 74 mph, and are exclusively formed over the Atlantic Ocean or eastern Pacific Ocean. Despite my longtime interest in storms and hurricanes, my level of expertise in these subjects is fairly limited. Because of this, I prefer to give you a curated list of some facts about hurricanes that I’ve collected from the following sources: National Oceanic and Atmospheric Administration (NOAA): https://www.noaa.gov/education/resource-collections/weather-atmosphere/hurricanes SciJinks: It’s all about weather! https://scijinks.gov/hurricane/ NASA Space Place: How Do Hurricanes Form? https://spaceplace.nasa.gov/hurricanes/en/ 2.1.1 Tropical Cyclones Hurricanes are the most powerful and violent storms on Earth. They form near the equator over warm ocean waters. The scientific term for all these storms is tropical cyclone. A tropical cyclone is a rotating low-pressure weather system that produces strong winds, has organized thunderstorms, and comes with heavy rainfall. If it hits land, it typically creates storm surge flooding, tornadoes, and rip currents. People call these storms by other names, such as typhoons or cyclones, depending on where they occur. Only tropical cyclones that form over the Atlantic Ocean or eastern Pacific Ocean are called “hurricanes.” Figure 2.2: Nomenclature of tropical cyclones around the world. 2.1.2 Storm Classification Tropical cyclones are classified by their maximum wind speed: Winds less than 39 mph: Tropical depressions Winds 39-73 mph: Tropical storms Winds 74 mph or greater: Hurricanes Scientifically speaking, Hurricanes are tropical cyclones whose sustained winds have reached 74 mph. At this point the hurricane reaches category 1 on the Saffir-Simpson Hurricane Wind Scale. The Saffir-Simpson Hurricane Wind Scale is a 1 to 5 rating based on a hurricane’s sustained wind speed: category 1: 74-95 mph; 64-82 kt; 119-153 km/h category 2: 96-110 mph; 83-95 kt; 154-177 km/h category 3: 111-129 mph; 96-112 kt; 178-208 km/h category 4: 130-156 mph; 113-136 kt; 209-251 km/h category 5: 157 mph or higher; 137 kt or higher; 252 km/h or higher Major hurricanes are defined as Category 3, 4, and 5 storms. The scale was created by wind engineer Herb Saffir and meteorologist Bob Simpson to help explain damage that buildings will sustain under different wind speeds. Note that the Saffir-Simpson scale does not include hazards from rain, flooding, or storm surge. 2.1.3 Naming Storms Once a system escalates to tropical storm-level winds (39 mph or more), it is given a name. The names are chosen by an international committee of the World Meteorological Organization (WMO). The list of names is available at: https://www.nhc.noaa.gov/aboutnames.shtml The Atlantic Ocean hurricane-naming system has been around since 1953. For the first twenty-five or so years, hurricanes and tropical storms were exclusively given female names. In 1979, the names began alternating between masculine and feminine. The names proceed in alphabetical order, omitting the “difficult” letters Q, U, X, Y, and Z. Names are reused every six years, although the WMO may retire the name of a particularly deadly or costly storm. In the event that more than 21 named tropical cyclones occur in the Atlantic basin in a season, or more than 24 named tropical cyclones in the eastern North Pacific basin, any additional storms will take names from an alternate list of names approved by the WMO for each basin. 2.1.4 Atlantic Hurricane Season The official Atlantic hurricane season runs from June through November, but occasionally storms form outside those months. September is the most active month (where most of the hurricanes occur), followed by August, and October (based on 1851 to 2015 data). A typical year has 12 named storms, including six hurricanes of which three become major hurricanes (category 3, 4, and 5). No hurricanes made U.S. landfall before June and after November during the period studied (1851 to 2015 data). 2.1.5 Storm Formation To close this chapter, take a look at the following diagram that beautifully describes and illustrates the formation of hurricanes. Source: https://scijinks.gov/hurricane/ Figure 2.3: How do hurricanes form? (source: SciJinks) If you want to know more about the formation of hurricanes, you can also watch the following video by NOAA SciJinks: https://www.youtube.com/embed/wPDoIrGUrEc "],["storms.html", "3 Data Set storms 3.1 Atlantic Hurricane Data 3.2 General Inspection", " 3 Data Set storms In order to have a gentle introduction, we are going to use the data set storms that comes in one of the most popular tidyverse packages: \"dplyr\". This package contains a large number of functions that allow us to manipulate tables in a substantially consistent and user-friendly way. We will also start with some of the graphing functions from the package \"ggplot2\" to produce simple visualizations. 3.1 Atlantic Hurricane Data The aforementioned data set storms is a curated table from the so-called Hurricane Databases (HURDAT), which is a collection of databases managed by the National Hurricane Center (NHC). HURDAT involves two databases: one for storms occurring in the Atlantic Ocean, and another one for storms occurring in the Eastern Pacific Ocean. HURDAT contains records from year 1851 till present. Keep in mind that in the past (before 1970s?), tropical depressions, that did not develop into tropical storms or hurricanes were not included within the database. An interesting note from Wikipedia: around 1963, NASA’s Apollo space program requested data, on the climatological impacts of tropical cyclones on launches of space vehicles at the Kennedy Space Center. The basic data was taken from the National Weather Records North Atlantic Tropical to include data from 1886–1968. As a result of this work, a requirement for a computerized tropical cyclone database at the National Hurricane Center (NHC) was realized. https://en.wikipedia.org/wiki/HURDAT 3.1.1 Data storms The package \"dplyr\" contains a dataset called storms which is a subset of the NOAA Atlantic hurricane database best track data. This database is one of several data sets available in the National Hurricane Center (NHC) Data Archive, which is part of the National Oceanic and Atmospheric Administration (NOAA). In case you are curious about the specifications and format of this type of data, you can visit the following link: http://www.nhc.noaa.gov/data/#hurdat The data storms includes the positions and attributes of tropical systems in the North Atlantic. If you are using a version of \"dplyr\" greater than or equal to 1.0.10, the storms are from the period 1975 to 2020, measured every six hours during the lifetime of a storm. Assuming that you’ve loaded \"tidyverse\" (or \"dplyr\") in R, when you type the name of the data object, you would get something like this: storms ## # A tibble: 11,859 × 13 ## name year month day hour lat long status categ…¹ wind press…² ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; ## 1 Amy 1975 6 27 0 27.5 -79 tropical dep… -1 25 1013 ## 2 Amy 1975 6 27 6 28.5 -79 tropical dep… -1 25 1013 ## 3 Amy 1975 6 27 12 29.5 -79 tropical dep… -1 25 1013 ## 4 Amy 1975 6 27 18 30.5 -79 tropical dep… -1 25 1013 ## 5 Amy 1975 6 28 0 31.5 -78.8 tropical dep… -1 25 1012 ## 6 Amy 1975 6 28 6 32.4 -78.7 tropical dep… -1 25 1012 ## 7 Amy 1975 6 28 12 33.3 -78 tropical dep… -1 25 1011 ## 8 Amy 1975 6 28 18 34 -77 tropical dep… -1 30 1006 ## 9 Amy 1975 6 29 0 34.4 -75.8 tropical sto… 0 35 1004 ## 10 Amy 1975 6 29 6 34 -74.8 tropical sto… 0 40 1002 ## # … with 11,849 more rows, 2 more variables: ## # tropicalstorm_force_diameter &lt;int&gt;, hurricane_force_diameter &lt;int&gt;, and ## # abbreviated variable names ¹​category, ²​pressure Let’s describe what’s going on in the above output. As you can tell, storms is a tibble object, which is one of the data objects in R that handles data in tabular format. tibbles are not a native R object; instead they are a modern version of data frames, and their related functions come from the homonym package \"tibble\". The way tibbles are printed or displayed is very interesting. the number of rows that are displayed is limited to 10; depending on the width of the printing space, you will only see a few columns shown to fit such width, underneath the name of each column there is a three letter abbreviation inside angle brackets, this abbreviation indicates the data type used by R to store the values: &lt;chr&gt; stands for character data &lt;dbl&gt; means double (i.e. real numbers or numbers with decimal digits) &lt;int&gt; means integer (numbers with no decimal digits) &lt;ord&gt; indicates an ordinal factor which is how R handles categorical data &lt;log&gt; indicates logical or boolean values (e.g. true and false) notice that the last three lines indicate the number of additional rows as well as the number of additional columns and their names. 3.1.2 storms Documentation You can find a more technical description of storms by taking a peek at its manual (or help) documentation. All you need to do is run this command: ?storms Here’s a full description of all the columns: name: Storm name year, month, and day: Date of report hour: Hour of report (in UTC) lat: Latitude long: Longitude status: Storm classification (Tropical Depression, Tropical Storm, or Hurricane) category: Saffir-Simpson storm category (estimated from wind speed. -1 = Tropical Depression, 0 = Tropical Storm) wind: storm’s maximum sustained wind speed (in knots) pressure: Air pressure at the storm’s center (in millibars) ts_diameter: Diameter of the area experiencing tropical storm strength winds (34 knots or above) hu_diameter: Diameter of the area experiencing hurricane strength winds (64 knots or above) You can take a look at the manual (or help) documentation to confirm the description of the variables in data storms. Some Remarks The data table storms is already in R; later you will learn how to import tables in R The table is already clean, there’s no need to fix weird values, or transform from one data type to another. Not only the table is clean, but it is also tidy which is the technical term to indicate that: every column is a variable. every row is an observation. every cell is a single value. 3.2 General Inspection When dealing with a data table, especially for the first time, I like to do a quick inspection of the general structure of the data, meaning the number of rows and columns, the name and data-type of each column, and some times also to quickly inspect a few rows either at the top or at the bottom of the table. To do all these things there is a handful of functions: str(): to get a summary of the table’s structure dim(): to get the dimensions (number of rows and columns) nrow(): to get just the number of rows ncol(): to get just the number of columns names(): to get the column names; there’s also colnames() head(): to look at a few first rows tail(): to look at a few last rows For instance, to get a general summary of the table’s structure, we can use str() and its argument vec.len = 1 to simplify the amount of output: str(storms, vec.len = 1) ## tibble [11,859 × 13] (S3: tbl_df/tbl/data.frame) ## $ name : chr [1:11859] &quot;Amy&quot; ... ## $ year : num [1:11859] 1975 ... ## $ month : num [1:11859] 6 6 ... ## $ day : int [1:11859] 27 27 ... ## $ hour : num [1:11859] 0 6 ... ## $ lat : num [1:11859] 27.5 28.5 ... ## $ long : num [1:11859] -79 -79 ... ## $ status : chr [1:11859] &quot;tropical depression&quot; ... ## $ category : Ord.factor w/ 7 levels &quot;-1&quot;&lt;&quot;0&quot;&lt;&quot;1&quot;&lt;&quot;2&quot;&lt;..: 1 1 ... ## $ wind : int [1:11859] 25 25 ... ## $ pressure : int [1:11859] 1013 1013 ... ## $ tropicalstorm_force_diameter: int [1:11859] NA NA ... ## $ hurricane_force_diameter : int [1:11859] NA NA ... Likewise, to explore the dimensions, that is the number of rows and columns, you can invoke dim(): dim(storms) ## [1] 11859 13 Alternatively, you can also call nrow() or ncol() if you prefer to get just the number of rows or just the number of columns: nrow(storms) ## [1] 11859 ncol(storms) ## [1] 13 Often, I like to use head() and/or tail() to see the first and/or the last rows of a table. In this way I can get an idea of what the data looks like without having to print all the entries. tail(storms) ## # A tibble: 6 × 13 ## name year month day hour lat long status categ…¹ wind press…² tropi…³ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Iota 2020 11 17 6 13.7 -83.8 hurri… 3 110 935 310 ## 2 Iota 2020 11 17 12 13.7 -84.7 hurri… 1 75 965 270 ## 3 Iota 2020 11 17 18 13.7 -85.7 tropi… 0 55 988 210 ## 4 Iota 2020 11 18 0 13.8 -86.7 tropi… 0 40 1000 140 ## 5 Iota 2020 11 18 6 13.8 -87.8 tropi… 0 35 1005 140 ## 6 Iota 2020 11 18 12 13.7 -89 tropi… -1 25 1006 0 ## # … with 1 more variable: hurricane_force_diameter &lt;int&gt;, and abbreviated ## # variable names ¹​category, ²​pressure, ³​tropicalstorm_force_diameter "],["single-columns.html", "4 Inspecting Single Columns 4.1 Basic Inspection of Year 4.2 Basic inspection of month 4.3 Your Turn", " 4 Inspecting Single Columns As we just saw, because storms is an object of class \"tibble\", when you type its name R displays the first 10 rows, which belong to storm Amy in 1975: storms ## # A tibble: 11,859 × 13 ## name year month day hour lat long status categ…¹ wind press…² ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; ## 1 Amy 1975 6 27 0 27.5 -79 tropical dep… -1 25 1013 ## 2 Amy 1975 6 27 6 28.5 -79 tropical dep… -1 25 1013 ## 3 Amy 1975 6 27 12 29.5 -79 tropical dep… -1 25 1013 ## 4 Amy 1975 6 27 18 30.5 -79 tropical dep… -1 25 1013 ## 5 Amy 1975 6 28 0 31.5 -78.8 tropical dep… -1 25 1012 ## 6 Amy 1975 6 28 6 32.4 -78.7 tropical dep… -1 25 1012 ## 7 Amy 1975 6 28 12 33.3 -78 tropical dep… -1 25 1011 ## 8 Amy 1975 6 28 18 34 -77 tropical dep… -1 30 1006 ## 9 Amy 1975 6 29 0 34.4 -75.8 tropical sto… 0 35 1004 ## 10 Amy 1975 6 29 6 34 -74.8 tropical sto… 0 40 1002 ## # … with 11,849 more rows, 2 more variables: ## # tropicalstorm_force_diameter &lt;int&gt;, hurricane_force_diameter &lt;int&gt;, and ## # abbreviated variable names ¹​category, ²​pressure From this output, it is obvious that the data contains at least one storm from 1975. But what other year values are present in the data? According to the manual documentation of storms (\"dplyr\" version 1.0.10): \"The data includes the positions and attributes of storms from 1975-2020\" In a more or less arbitrary way, let’s begin inspecting storms by focusing on column year. 4.1 Basic Inspection of Year Let’s formalize our first exploratory question: What years have the data been collected for? To answer this question, we need to work with column year. There are several ways in R to manipulate a column from a tabular object. Using \"dplyr\", there are two basic kinds of functions to extract variables: pull() and select(). Figure 4.1: Extracting a column with dplyr functions “pull” and “select” Let’s do a sanity check of years. We can use the function pull() that pulls or extracts an entire column. Because there are thousands of values in year, let’s also use unique() to find out the set of year values in the data. First we pull the year, and then we identify unique occurrences: unique(pull(storms, year)) ## [1] 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 ## [16] 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 ## [31] 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 ## [46] 2020 Based on this output, we can see that storms has records during a 45-year period since 1975 to 2020. The same can be accomplished with unique() and select(). unique(select(storms, year)) ## # A tibble: 46 × 1 ## year ## &lt;dbl&gt; ## 1 1975 ## 2 1976 ## 3 1977 ## 4 1978 ## 5 1979 ## 6 1980 ## 7 1981 ## 8 1982 ## 9 1983 ## 10 1984 ## # … with 36 more rows Can you notice the difference between pull() and select()? The difference is minor but important. Conceptually speaking, both functions return the same values. However, the format of their output is not the same. Observe that select() returns output in a tibble format. In contrast, the output of pull() is not in a tabular format but rather in a vector (i.e. contiguous set of values). Interestingly, there is a third option that can be used to find the unique or distinct year values: using the function distinct() distinct(storms, year) ## # A tibble: 46 × 1 ## year ## &lt;dbl&gt; ## 1 1975 ## 2 1976 ## 3 1977 ## 4 1978 ## 5 1979 ## 6 1980 ## 7 1981 ## 8 1982 ## 9 1983 ## 10 1984 ## # … with 36 more rows Again, notice the tabular output returned by distinct(). 4.1.1 Barplot of year values Let’s keep using the values in column year to obtain our first visualization with \"ggplot2\" functions. You could certainly begin a visual exploration of other variables, but we think year is a good place to start because it’s a numeric variable, measured on a discrete scale, and this is a good candidate to use barcharts (the most popular type of graphic). \"ggplot2\" comes with a large number of functions to create almost any type of chart. Luckily for us, it already comes with predefined functions to graph barcharts. The syntax may seem a bit scary for beginners, but you will see that it follows a logical structure. Here’s the code to make a barplot of values in year: # barchart of year values ggplot(data = storms) + geom_bar(aes(x = year)) How does the previous command work? First, we always call the ggplot() function, typically indicating the name of the table to be used with the data argument. Then, we add more components, or layers, using the plus + operator. In this case we are adding just one layer: a geom_bar() component which is the geometric object for bars. To tell ggplot() that year is the column in data = storms to be used for the x-axis, we map x = year inside the aes() function which stands for aesthetic mapping. We should clarify that the meaning of “aesthetic” as used by \"ggplot2\" does not mean beautiful or pretty, instead it conserves its etymological meaning of perception. Simply put, aes() is the function that you use to tell ggplot() which variables of a data object will be mapped as visual attributes of graphical elements. 4.2 Basic inspection of month Now that we have explored column year, we can move to the column month and perform similar type of analysis. Using the same commands, all we have to do is change the name of the variable to month to see whether there are storms in all months: unique(pull(storms, month)) ## [1] 6 7 8 9 10 11 12 5 4 1 In this case, it would be better if we sort() them: sort(unique(pull(storms, month))) ## [1] 1 4 5 6 7 8 9 10 11 12 Observe that not all months have recorded storms, this is the case for February (2) and March (3). Is this something to be concerned about? How is it possible that there are no recorded data for February and March? For the inexperience analyst, asking this type of questions is fundamental. As a data scientist, you will be working with data sets for which you are not necessarily an expert in that particular field of application. Since you will also be interacting with some type of experts, you should ask them as many questions as possible to clarify your understanding of the data and its context. The answer for not having storms in February and March is because these months have to do with the end of Winter and beginning of Spring in the North Atlantic, which is a period of time where tropical systems don’t get formed. In fact, Spring months such as April and May also don’t tend to be typical months for hurricanes. So a further thing to explore could involve computing the number of storms in April and May. 4.3 Your Turn Use pull(), select(), and unique() to inspect the values in column day Try to use sort() in order to arrange the unique values of day Does the unique day values make sense? Are there days for which there seem to be no recorded storm data? Use \"ggplot2\" functions to graph a barchart for the values in columns month. Use \"ggplot2\" functions to graph a barchart for the values in columns day. Look at the cheatsheet for ggplot and locate the information for geom_bar(). Find out how to specify: border color, fill color. Also, see what happens when you specify alpha = 0.5. Look at the cheatsheet for ggplot and locate the information for background Themes, e.g. theme_bw(). Find out how to add theme theme_classic() to the previous barchart. Look at the cheatsheet for ggplot and locate the information for Labels. Find out how to add a title with ggtitle() as well as with labs() to one of your previous barcharts. "],["storms-in-1975.html", "5 Storms in 1975 5.1 Visualizing 1975 data", " 5 Storms in 1975 Let’s focus on those storms recorded in 1975. How do we select them? Computationally, this operation involves a logical condition: year == 1975. This condition means that, from all the available year values, we get those that match 1975. This is done via \"dplyr\" function filter() Figure 5.1: Extracting certain rows with dplyr function “filter” First, let’s create a subset storms75 by filtering those rows with year equal to 1975: storms75 &lt;- filter(storms, year == 1975) storms75 ## # A tibble: 86 × 13 ## name year month day hour lat long status categ…¹ wind press…² ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; ## 1 Amy 1975 6 27 0 27.5 -79 tropical dep… -1 25 1013 ## 2 Amy 1975 6 27 6 28.5 -79 tropical dep… -1 25 1013 ## 3 Amy 1975 6 27 12 29.5 -79 tropical dep… -1 25 1013 ## 4 Amy 1975 6 27 18 30.5 -79 tropical dep… -1 25 1013 ## 5 Amy 1975 6 28 0 31.5 -78.8 tropical dep… -1 25 1012 ## 6 Amy 1975 6 28 6 32.4 -78.7 tropical dep… -1 25 1012 ## 7 Amy 1975 6 28 12 33.3 -78 tropical dep… -1 25 1011 ## 8 Amy 1975 6 28 18 34 -77 tropical dep… -1 30 1006 ## 9 Amy 1975 6 29 0 34.4 -75.8 tropical sto… 0 35 1004 ## 10 Amy 1975 6 29 6 34 -74.8 tropical sto… 0 40 1002 ## # … with 76 more rows, 2 more variables: tropicalstorm_force_diameter &lt;int&gt;, ## # hurricane_force_diameter &lt;int&gt;, and abbreviated variable names ¹​category, ## # ²​pressure Once we have the set of storms that occurred in 1975, one possible question to ask is what unique() storms happened in that year: unique(pull(storms75, name)) ## [1] &quot;Amy&quot; &quot;Caroline&quot; &quot;Doris&quot; From the returned output, there are only three unique storms recorded in 1975. Recall that a similar result can be obtained with distinct(), the difference being the way in which the output is returned, in this case under the format of a tibble: distinct(storms75, name) ## # A tibble: 3 × 1 ## name ## &lt;chr&gt; ## 1 Amy ## 2 Caroline ## 3 Doris Now that we know there are three storms for 1975, it would be nice to count the number of rows or entries for each of them. \"dplyr\" allows us to do this with count(), passing the name of the table, and then the name of the column for which we want to get the counts or frequencies: count(storms75, name) ## # A tibble: 3 × 2 ## name n ## &lt;chr&gt; &lt;int&gt; ## 1 Amy 30 ## 2 Caroline 33 ## 3 Doris 23 5.1 Visualizing 1975 data Let’s play a bit with those storms from 1975. More specifically, let’s visually explore the values of columns wind and pressure. storms75 ## # A tibble: 86 × 13 ## name year month day hour lat long status categ…¹ wind press…² ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; ## 1 Amy 1975 6 27 0 27.5 -79 tropical dep… -1 25 1013 ## 2 Amy 1975 6 27 6 28.5 -79 tropical dep… -1 25 1013 ## 3 Amy 1975 6 27 12 29.5 -79 tropical dep… -1 25 1013 ## 4 Amy 1975 6 27 18 30.5 -79 tropical dep… -1 25 1013 ## 5 Amy 1975 6 28 0 31.5 -78.8 tropical dep… -1 25 1012 ## 6 Amy 1975 6 28 6 32.4 -78.7 tropical dep… -1 25 1012 ## 7 Amy 1975 6 28 12 33.3 -78 tropical dep… -1 25 1011 ## 8 Amy 1975 6 28 18 34 -77 tropical dep… -1 30 1006 ## 9 Amy 1975 6 29 0 34.4 -75.8 tropical sto… 0 35 1004 ## 10 Amy 1975 6 29 6 34 -74.8 tropical sto… 0 40 1002 ## # … with 76 more rows, 2 more variables: tropicalstorm_force_diameter &lt;int&gt;, ## # hurricane_force_diameter &lt;int&gt;, and abbreviated variable names ¹​category, ## # ²​pressure What type of visual display can we use to graph wind speed? The answer to this question is based by determining which type of variable wind is. You would agree with us in saying that wind is a quantitative variable. So one graphing option can be either a histogram or a boxplot, which are statistical charts to visualize the distribution of quantitative variables. 5.1.1 Histograms Let’s begin with a histogram. The associated geom_() function to plot a histogram is geom_histogram(). We are going to show you a synatx of ggplot() slightly different from the one we used for the barcharts. Carefully review the following code: ggplot(data = storms75, aes(x = wind)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. You should notice now that aes() is an argument of ggplot(), and not anymore an argument of the geometric-object function geom_histogram(). While this may be a bit confusing when learning about \"ggplot2\", it is a very flexible and powerful behavior of aes(). Again, the important part of aes() is to understand that this function allows you to tell ggplot() which variables in your data table are used as visual attributes of the corresponding geometric elements forming the plot. We can change the default argument binwidth to get another version of the histogram, for example a bin-width of 5 units (i.e. width of 5 knots): ggplot(data = storms75, aes(x = wind)) + geom_histogram(binwidth = 5) or a bin-width of 10: ggplot(data = storms75, aes(x = wind)) + geom_histogram(binwidth = 10) Now, let’s reflect on what’s going on in each of the histograms. Do they make sense? How do we interpret each figure? 5.1.2 Boxplots While ggplot() does what we ask it to do, the displays may not be the most useful, or meaningful. Why? Think what exactly it is that we are plotting. In 1975, there are three storms: unique(pull(storms75, name)) ## [1] &quot;Amy&quot; &quot;Caroline&quot; &quot;Doris&quot; But the histograms are not differentiating between any of those three storms. Rather, the visualization is just giving us a general view of the wind values, from the low 20’s to the high 90’s, or to be more precise: summary(pull(storms75, wind)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 20.00 25.00 52.50 50.87 65.00 100.00 However, we don’t really know if all three storms have the same minimum wind speed, or the same maximum wind speed. The good news is that we can tell ggplot() to take into account each different storm name. But now let’s use boxplots via geom_boxplot(), mapping name to the x-axis, and wind to the y-axis. ggplot(data = storms75, aes(x = name, y = wind)) + geom_boxplot() Note how different the distribution of wind speed is in each storm. We can get an alternative plot with density curves thanks to the geom_density() function. The syntax in this case is different. Let’s first do it without separating storms, and then we do it taking into account the storm names. 5.1.3 Density Curves Here’s the command that plots a density curve of wind, without distinguishing between storms. Observe also how the argument fill is set to color 'gray': ggplot(data = storms75, aes(x = wind)) + geom_density(fill = &#39;gray&#39;) As you can tell, the density curve looks like the profile of a roller coaster, or like the silhouette of three mountain peaks. Is this a pattern followed by wind speed in all storms? Or is it just an artifact due to the fact that we are plotting data without taking into consideration the context of storms75? Let’s replot density of wind, but now distinguishing between each storm. We do this by mapping name to the color argument: ggplot(data = storms75, aes(x = wind, color = name)) + geom_density(aes(fill = name)) Aha! Now things look more interesting: the roller coaster shape of the first call to geom_density() turned out to be an artificial pattern. As you can tell from the above plot, each storm has its own different density curve. To get a better visualization, we can take the previous command and add a bit of transparency to the colors, this is done with the argument alpha inside geom_density(). Note how arguments are specified inside geom_density(): we map name to the color-fill attribute of the curve inside aes(), but we set alpha = 0.5 outside aes(): ggplot(data = storms75, aes(x = wind, color = name)) + geom_density(aes(fill = name), alpha = 0.5) 5.1.4 Facets We are going to take advantage of the preceding graphic to introduce another cool feature of \"ggplot2\" that allows us to split data based on categorical or discrete variables, in order to produce separated frames called facets. Below is the previous command—without alpha transparency—adding a new layer given by facet_wrap() taking into account the name of the storms: ggplot(data = storms75, aes(x = wind, color = name)) + geom_density(aes(fill = name)) + facet_wrap(~ name) In this command we are creating facets by name. This means that we obtain a facet for each unique category of name. In other words, we get separated density curves, one for each storm. The syntax inside facet_wrap() uses the tilde ~ operator which is the formula operator in R. Basically, the command ~ name tells ggplot() to create facets “based on” or “conditioning on” the values of name. Here’s a question for your: Which of the three storms in 1975 was the strongest one (in terms of the amount of sustained wind speeds)? "],["storm-amy-1975.html", "6 Storm Amy (1975) 6.1 Exploring wind 6.2 Exploring pressure 6.3 Your Turn", " 6 Storm Amy (1975) Let’s focus on storm Amy in 1975, subsetting storms75 to filter out just the rows of Amy into its own table amy75 &lt;- filter(storms75, name == &quot;Amy&quot;) amy75 ## # A tibble: 30 × 13 ## name year month day hour lat long status categ…¹ wind press…² ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; ## 1 Amy 1975 6 27 0 27.5 -79 tropical dep… -1 25 1013 ## 2 Amy 1975 6 27 6 28.5 -79 tropical dep… -1 25 1013 ## 3 Amy 1975 6 27 12 29.5 -79 tropical dep… -1 25 1013 ## 4 Amy 1975 6 27 18 30.5 -79 tropical dep… -1 25 1013 ## 5 Amy 1975 6 28 0 31.5 -78.8 tropical dep… -1 25 1012 ## 6 Amy 1975 6 28 6 32.4 -78.7 tropical dep… -1 25 1012 ## 7 Amy 1975 6 28 12 33.3 -78 tropical dep… -1 25 1011 ## 8 Amy 1975 6 28 18 34 -77 tropical dep… -1 30 1006 ## 9 Amy 1975 6 29 0 34.4 -75.8 tropical sto… 0 35 1004 ## 10 Amy 1975 6 29 6 34 -74.8 tropical sto… 0 40 1002 ## # … with 20 more rows, 2 more variables: tropicalstorm_force_diameter &lt;int&gt;, ## # hurricane_force_diameter &lt;int&gt;, and abbreviated variable names ¹​category, ## # ²​pressure 6.1 Exploring wind Let’s keep exploring wind but now let’s do it chronologically, that is, graphing the wind values in the order that they were recorded (recall storms are tracked every six hours). We begin with a scatterplot using geom_point(), and we specify that the x-axis should use a numeric sequence 1:nrow(amy75) from the first row till the last row of amy75, and wind for y-axis: ggplot(data = amy75, aes(x = 1:nrow(amy75), y = wind)) + geom_point() Because the x-axis denotes progression over time, we can connect the dots with a line. A simple way to do this is by adding another layer to our plot, this time with geom_line() ggplot(data = amy75, aes(x = 1:nrow(amy75), y = wind)) + geom_point() + geom_line() As you can tell, Amy started to being recorded with wind speed of 25 knots, and then after (7 x 6) = 42 hours, its speed kept increasing to 30, 35, 40, and so on until reaching its maximum speed of 60 knots that lasted 54 hours (9 x 6). At this point, we can ask about the status of Amy along its lifetime. One option is to map status to the color attribute of points: ggplot(data = amy75, aes(x = 1:nrow(amy75), y = wind)) + geom_point(aes(color = status)) + geom_line() We see that Amy started as a tropical depression, and then became a tropical storm, but never became a hurricane. For a storm to reach hurricane status, of category 1, it must have one-minute maximum sustained winds of at least 64 kn (33 m/s; 74 mph; 119 km/h). 6.2 Exploring pressure What about the pressure values of Amy? We can produce a similar scatterplot with a line connecting the dots: ggplot(data = amy75, aes(x = 1:nrow(amy75), y = pressure)) + geom_point(aes(color = status)) + geom_line() As an exploratory exercise, we can also play with the size of points, the size (width) of lines, colors, etc. Here’s one suggestion graphing pressure and taking into account the wind speed reflected in the size of points and line segments: ggplot(data = amy75, aes(x = 1:nrow(amy75), y = pressure)) + geom_line(aes(size = wind), lineend = &quot;round&quot;, color = &#39;gray70&#39;) + geom_point(aes(size = wind, color = status)) If you know a little bit about storms, you know that there’s actually an association between wind and pressure. But let’s pretend for a second that we don’t know much about tropical storms, hurricanes, and things like that. By looking at the previous chart, this should allows us to guess that something is going on between the pressure of a storm and its wind speed. As Amy becomes stronger, with higher winds, its pressure levels drop accordingly, suggesting a negative correlation, which is confirmed when we compute this statistic: summarise(amy75, cor(wind, pressure)) ## # A tibble: 1 × 1 ## `cor(wind, pressure)` ## &lt;dbl&gt; ## 1 -0.956 6.3 Your Turn Repeat the previous exploratory steps but now with storms from year 1980. Try to find out how to specify a logical condition to filter various years: for example, storms from years 1975, 1976, and 1977. Try to find out how to specify a logical condition to filter storms from year 1975 with wind values less than 100. Use \"dplyr\" functions/commands to create a table (e.g. tibble) storm_names_1980s containing the name and year of storms recorded during the 1980s (i.e. from 1980 to 1989). Create boxplots of pressure, for storms in 1980. You can also try graphing violins (geom_violin()) instead of boxplots (geom_boxplot()). Use \"ggplot2\" functions to make a single scatterplot of wind and pressure for all storms. Use category to add color to the dots. Use \"ggplot2\" functions to make a scatterplot of wind and pressure for all storms, facetting by month, and using category to differentiate by color. Use \"ggplot2\" functions to make a scatterplot of wind and pressure for all storms, but now create facets based on month. Feel free to add some amount of alpha transparency to the color of dots. "],["summarizing-1975-data.html", "7 Summarizing 1975 Data 7.1 Group-by Operations 7.2 Arrange operations 7.3 Further inspection of 1975 storm Amy", " 7 Summarizing 1975 Data We’ve been working with the table storms75, which was obtained by filtering those rows with year equal to 1975: storms75 &lt;- filter(storms, year == 1975) storms75 ## # A tibble: 86 × 13 ## name year month day hour lat long status categ…¹ wind press…² ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; ## 1 Amy 1975 6 27 0 27.5 -79 tropical dep… -1 25 1013 ## 2 Amy 1975 6 27 6 28.5 -79 tropical dep… -1 25 1013 ## 3 Amy 1975 6 27 12 29.5 -79 tropical dep… -1 25 1013 ## 4 Amy 1975 6 27 18 30.5 -79 tropical dep… -1 25 1013 ## 5 Amy 1975 6 28 0 31.5 -78.8 tropical dep… -1 25 1012 ## 6 Amy 1975 6 28 6 32.4 -78.7 tropical dep… -1 25 1012 ## 7 Amy 1975 6 28 12 33.3 -78 tropical dep… -1 25 1011 ## 8 Amy 1975 6 28 18 34 -77 tropical dep… -1 30 1006 ## 9 Amy 1975 6 29 0 34.4 -75.8 tropical sto… 0 35 1004 ## 10 Amy 1975 6 29 6 34 -74.8 tropical sto… 0 40 1002 ## # … with 76 more rows, 2 more variables: tropicalstorm_force_diameter &lt;int&gt;, ## # hurricane_force_diameter &lt;int&gt;, and abbreviated variable names ¹​category, ## # ²​pressure 7.1 Group-by Operations Another common task when exploring data has to do with computations applied on certain groups or categories of data. \"dplyr\" provides the function group_by() which takes a data table, and we specify the column(s) on which rows will be grouped by: Figure 7.1: Group-by operations For example, we may be interested in calculating the average wind speed and average pressure of each storm in 1975. First we need to group by name, and then we use summarise() to indicate that we want to get the mean() of wind and pressure, like this: summarise( group_by(storms75, name), avg_wind = mean(wind), avg_pressure = mean(pressure) ) ## # A tibble: 3 × 3 ## name avg_wind avg_pressure ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Amy 46.5 995. ## 2 Caroline 38.9 1002. ## 3 Doris 73.7 983. Sometimes, you’ll find convenient to assign the output into its own table: avg_wind_pressure_75 &lt;- summarise( group_by(storms75, name), avg_wind = mean(wind), avg_pressure = mean(pressure) ) avg_wind_pressure_75 ## # A tibble: 3 × 3 ## name avg_wind avg_pressure ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Amy 46.5 995. ## 2 Caroline 38.9 1002. ## 3 Doris 73.7 983. 7.2 Arrange operations The table of summary means avg_wind_pressure_75 is ordered alphabetically by name. But perhaps you may want to organize its contents by avg_wind or by avg_pressure. Let’s see how to do this. Besides group_by() operations, another common type of manipulation is the arragement of rows based on the values of one or more columns. In \"dplyr\", this can easily be achieved with the function arrange(). The way this function works is passing the name of the table, and then specifying one or more columns to order rows based on such values. Figure 7.2: Arranging rows Say you want to arrange the contents of the average summary table, by taking into account the column avg_wind: arrange(avg_wind_pressure_75, avg_wind) ## # A tibble: 3 × 3 ## name avg_wind avg_pressure ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Caroline 38.9 1002. ## 2 Amy 46.5 995. ## 3 Doris 73.7 983. Likewise, you can also arrange the averages by avg_pressure: arrange(avg_wind_pressure_75, avg_pressure) ## # A tibble: 3 × 3 ## name avg_wind avg_pressure ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Doris 73.7 983. ## 2 Amy 46.5 995. ## 3 Caroline 38.9 1002. The default behavior of arrange() is to organize rows in increasing order. But what if you want to organize rows in decreasing order? No problem, just use the auxiliary function desc() to indicate that rows should be arranged decreasingly: arrange(avg_wind_pressure_75, desc(avg_wind)) ## # A tibble: 3 × 3 ## name avg_wind avg_pressure ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Doris 73.7 983. ## 2 Amy 46.5 995. ## 3 Caroline 38.9 1002. 7.3 Further inspection of 1975 storm Amy Let’s focus on a specific storm, for example storm Amy in 1975. For sake of simplicity, we are going to create a table amy75 containing the values of this storm: amy75 &lt;- filter(storms75, name == &quot;Amy&quot;) amy75 ## # A tibble: 30 × 13 ## name year month day hour lat long status categ…¹ wind press…² ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; ## 1 Amy 1975 6 27 0 27.5 -79 tropical dep… -1 25 1013 ## 2 Amy 1975 6 27 6 28.5 -79 tropical dep… -1 25 1013 ## 3 Amy 1975 6 27 12 29.5 -79 tropical dep… -1 25 1013 ## 4 Amy 1975 6 27 18 30.5 -79 tropical dep… -1 25 1013 ## 5 Amy 1975 6 28 0 31.5 -78.8 tropical dep… -1 25 1012 ## 6 Amy 1975 6 28 6 32.4 -78.7 tropical dep… -1 25 1012 ## 7 Amy 1975 6 28 12 33.3 -78 tropical dep… -1 25 1011 ## 8 Amy 1975 6 28 18 34 -77 tropical dep… -1 30 1006 ## 9 Amy 1975 6 29 0 34.4 -75.8 tropical sto… 0 35 1004 ## 10 Amy 1975 6 29 6 34 -74.8 tropical sto… 0 40 1002 ## # … with 20 more rows, 2 more variables: tropicalstorm_force_diameter &lt;int&gt;, ## # hurricane_force_diameter &lt;int&gt;, and abbreviated variable names ¹​category, ## # ²​pressure Here’s a couple of questions that we could investigate: which are the status categories for Amy? during which months was Amy active? and for how many days? what are the basic summary statistics for wind and pressure? # which are the `status` categories for Amy? distinct(amy75, status) ## # A tibble: 2 × 1 ## status ## &lt;chr&gt; ## 1 tropical depression ## 2 tropical storm # during which months was Amy active? distinct(amy75, month) ## # A tibble: 2 × 1 ## month ## &lt;dbl&gt; ## 1 6 ## 2 7 # for how many days was Amy active? count(distinct(amy75, day)) ## # A tibble: 1 × 1 ## n ## &lt;int&gt; ## 1 8 # summary statistics for wind summary(select(amy75, wind)) ## wind ## Min. :25.00 ## 1st Qu.:31.25 ## Median :50.00 ## Mean :46.50 ## 3rd Qu.:60.00 ## Max. :60.00 # summary statistics for pressure summary(select(amy75, pressure)) ## pressure ## Min. : 981.0 ## 1st Qu.: 986.0 ## Median : 987.0 ## Mean : 995.1 ## 3rd Qu.:1005.5 ## Max. :1013.0 7.3.1 Your Turn Use \"dplyr\" functions/commands to create a table (e.g. tibble) max_wind_pressure_75 containing columns: 1)name of storm, 2) max_wind maximum wind speed, and 3) max_pressure maximum pressure Use \"dplyr\" functions/commands to create a table (e.g. tibble) wind_stats_75 containing columns: 1)name of storm, 2) min_wind minimum wind speed, 3) avg_wind mean wind speed, 4) med_wind median wind speed, and 5) max_wind maximum wind speed. "],["piper.html", "8 The Pipe Operator 8.1 Piping", " 8 The Pipe Operator This part introduces the pipe operator, denoted as %&gt;%, which allows you write function calls in a more human-readable way. This operator can be extremely useful in \"dplyr\" operations that require many steps. 8.1 Piping The behavior of \"dplyr\" is functional in the sense that function calls don’t have side-effects. This implies that you must always save their results in order to keep them in an object (in memory). The “ugly” side of this functional behavior is that it doesn’t lead to particularly elegant code, especially if you want to do many operations at once. For example, say you want to calculate the averages of wind speed, and air pressure, grouped by name, of storms in year 1975, displaying the output arranged by wind average. One option is to do calculations step-by-step, storing the intermediate results in their own data objects: # manipulation step-by-step dat1 = filter(storms, year == 1975) dat2 = group_by(dat1, name) dat3 = select(dat2, name, wind, pressure) dat4 = summarise(dat3, avg_wind = mean(wind, na.rm = TRUE), avg_pres = mean(pressure, na.rm = TRUE)) dat5 = arrange(dat4, avg_wind) dat5 ## # A tibble: 3 × 3 ## name avg_wind avg_pres ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Caroline 38.9 1002. ## 2 Amy 46.5 995. ## 3 Doris 73.7 983. Another option, if you don’t want to name the intermediate results, requires wrapping the function calls inside each other: # inside-out style (hard to read) arrange( summarise( select( group_by( filter(storms, year == 1975), name), name, wind, pressure), avg_wind = mean(wind, na.rm = TRUE), avg_pres = mean(pressure, na.rm = TRUE)), avg_wind) This is difficult to read because the order of the operations is from inside to out. Thus, the arguments are a long way away from the function. To get around this problem, \"dplyr\" provides the %&gt;% operator from the \"magrittr\" package. 8.1.1 The magrittr operator x %&gt;% f(y) turns into f(x, y) so you can use it to rewrite multiple operations that you can read left-to-right, top-to-bottom: # using %&gt;% storms %&gt;% filter(year == 1975) %&gt;% group_by(name) %&gt;% select(name, wind, pressure) %&gt;% summarise( avg_wind = mean(wind, na.rm = TRUE), avg_pres = mean(pressure, na.rm = TRUE)) %&gt;% arrange(avg_wind) ## # A tibble: 3 × 3 ## name avg_wind avg_pres ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Caroline 38.9 1002. ## 2 Amy 46.5 995. ## 3 Doris 73.7 983. "],["basic-maps.html", "9 Basic Maps 9.1 Graphing Maps", " 9 Basic Maps In the previous chapters, you were introduced to the basics of \"dplyr\" and \"ggplot2\", performing various operations on the data storms. Because this data set contains geographical information such as longitude and latitude, we need to take a further step in this module in order to learn about plotting basic geographical maps. You will need the following packages: library(tidyverse) # for syntactic manipulation of tables library(maps) # for drawing basic geographical maps and the following objects: storms75 &lt;- filter(storms, year == 1975) 9.1 Graphing Maps In this part, we give a basic exposure to plotting maps with \"ggplot2\" and \"maps\". Keep in mind that there is a wide array of packages for graphing all sorts of maps, and geospatial information. Good resources to look at are: Drawing beautiful maps programmatically with R, sf and ggplot2 by Mel Moreno and Mathieu Basille; https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html Geocomputation with R by Robin Lovelace, Jakub Nowosad, and Jannes Muenchow; https://geocompr.robinlovelace.net Making Maps with R by Eric C. Anderson; https://eriqande.github.io/rep-res-web/lectures/making-maps-with-R.html 9.1.1 Plotting location of storm records For illustration purposes, we continue using the data frame storms75. Having latitude and longitude, we can make a scatterplot to see the location of the storm records. Recall that the ggplot function to do this is geom_point(). To distinguish each storm, we can color the dots by taking into account the different storm names. This involves mapping the column name to the color attribute: ggplot(data = storms75, aes(x = long, y = lat, color = name)) + geom_point() Keep in mind that the previous command can also be written as: # alternative ways to write equivalent commands ggplot(data = storms75) + geom_point(aes(x = long, y = lat, color = name)) ggplot() + geom_point(data = storms75, aes(x = long, y = lat, color = name)) The above scatterplot is a good starting point to visualize the location of the storm records, but it would be nice to have an actual image of a map. Let’s see how to do this in the following subsections. 9.1.2 Basic map One of the oldest ways to plot maps in R is with the package \"maps\". Nowadays, there are better packages for geospatial data and making maps, but let’s not worry about them at this moment. One rudimentary way to plot a map is by first getting data of the world. \"ggplot2\" provides the function map_data() to create the required data table with geospatial information of a world map. All you have to do is specify the name of the map provided by the \"maps\" package. In this example, let’s use the \"world\" map. Once we have this data, we can use it with ggplot() and a geom_polygon() layer like this: # world map data world_map &lt;- map_data(&quot;world&quot;) # a default world map ggplot() + geom_polygon(data = world_map, aes(x = long, y = lat, group = group)) In the above command, notice how we specify the data argument inside geom_polygon() instead of inside ggplot(). We do this because the data frame world_map is used to graph the layer of the map. We still need to add another layer—via geom_point()—for the coordinates indicating the position of each storm’s record. To handle the code more easily, let’s modify the map, and create a \"ggplot\" object called gg_world. We’ll use this object as our “canvas” for plotting the storm locations: # map &quot;canvas&quot; stored as gg_world gg_world &lt;- ggplot() + geom_polygon(data = world_map, aes(x = long, y = lat, group = group), fill = &quot;gray95&quot;, colour = &quot;gray70&quot;, size = 0.2) + theme_bw() gg_world 9.1.3 Mapping 1975 Storms Now that we know how to plot a map with ggplot(), we can add the points of the storm records. This is done with geom_point(), and specifying storms75 as the data argument inside this function. In other words, we are using two separate data frames. One is world_map, used to draw the polygons of the map; the other one is stomrs75 to graph the dots of each storm. Notice also that there are no inputs provided to the function ggplot(). # world map, adding storms in 1975 gg_world + geom_point(data = storms75, aes(x = long, y = lat, color = name)) Because the analyzed hurricanes occurred in the North Atlantic basin, we can focus on that region by modifying the x-and-y axis limits: # zoom-in gg_world + geom_point(data = storms75, aes(x = long, y = lat, color = name)) + xlim(c(-150, 0)) + ylim(c(0, 90)) It’s worth mentioning that this zooming-in has a secondary effect of distorting some of the polygons. For example, Alaska seems to get cut in half. Also the polygon of Colombia is incomplete. Ignoring these distortions for now, we can continue exploring things by taking into account more variables. For instance, let’s map the wind speed to the size argument of points. gg_world + geom_point(data = storms75, aes(x = long, y = lat, color = name, size = wind), alpha = 0.5) + xlim(c(-150, 0)) + ylim(c(0, 90)) A very similar appearance can be achieved by replacing geom_point() with geom_path(): gg_world + geom_path(data = storms75, aes(x = long, y = lat, color = name, size = wind), lineend = &quot;round&quot;, alpha = 0.4) + xlim(c(-150, 0)) + ylim(c(0, 90)) "],["less-basic-maps.html", "10 Less Basic Maps 10.1 More mapping approaches", " 10 Less Basic Maps The code in this chapter requires the following packages: library(tidyverse) # for syntactic manipulation of tables library(rnaturalearth) # world map data from Natural Earth library(rnaturalearthdata) # companion package of rnaturalearth and the following table for storms in 1975: storms75 &lt;- filter(storms, year == 1975) 10.1 More mapping approaches Another interesting map graphing approach is by using map-objects from the package \"rnaturalearth\". We use the ne_countries() function—from \"rnaturalearth\"—to get world country polygons. In the following command, we specify a medium scale resolution, and a returned object of class \"sf\" (simple features). # another world data frame world_df &lt;- ne_countries(scale = &quot;medium&quot;, returnclass = &quot;sf&quot;) class(world_df) ## [1] &quot;sf&quot; &quot;data.frame&quot; Now we can pass world_df to ggplot(), and use geom_sf() which is the function that allows us to visualize simple features objects \"sf\". # another world map (from &quot;rnaturalearth&quot;) ggplot(data = world_df) + geom_sf() + theme_bw() One advantage of using this other mapping approach is that we can zoom-in without having distorted polygons. To focus on a specific region, we set the x-axis and y-axis limits with the coord_sf() function. Again, for coding convenience, let’s create another \"ggplot\" object # ggplot object to be used as a canvas gg_world2 &lt;- ggplot(data = world_df) + geom_sf() + coord_sf(xlim = c(-150, 0), ylim = c(0, 90), expand = TRUE) + theme_bw() gg_world2 Now let’s add the storms: gg_world2 + geom_path(data = storms75, aes(x = long, y = lat, color = name), lineend = &quot;round&quot;, size = 2, alpha = 0.8) 10.1.1 Storms from 1975 to 1980 As a simple experiment, let’s graph storms between 1975 and 1980 (six years). First we create a dedicated data table storms_75_80 to select the rows we are interested in: storms_75_80 &lt;- filter(storms, year %in% 1975:1980) And then we can use facet_wrap(~ year) to graph storms by year: gg_world2 + geom_path(data = storms_75_80, aes(x = long, y = lat, group = name), lineend = &quot;round&quot;) + xlim(c(-150, 0)) + ylim(c(0, 90)) + facet_wrap(~ year) "],["summary.html", "11 Summary 11.1 Number of Storms per Year 11.2 Your Turn", " 11 Summary So far, we’ve covered several functions from \"dplyr\", as well as some other functions in R: functions from \"dplyr\" pull() and select() filter() group_by() arrange() and desc() count(), distinct(), summarise() functions in base R unique(), sort(), mean(), summary() 11.1 Number of Storms per Year If you recall, our first ggplot involved a barchart for the values in column year ggplot(data = storms) + geom_bar(aes(x = year)) We discovered that the 41-year period of recorded data from 1975 to 2015. We can take a further step and ask: how many storms are there in each year? To answer this question, we need to do some data manipulation with \"dplyr\". Our general recommendation when working with \"dplyr\"’s functions, especially when you are learning about them, is to do computations step by step, deciding which columns you need to use, which rows to consider, which functions to call, and so on. Think about the columns that we need to select to find the number of unique storms per year. We obviously need year, but this column alone it’s not enough because for any given storm we have multiple records with the same year. Therefore, we also need column name. For illustration purposes, we are going to build the data manipulation pipeline step by step. As you get more comfortable with \"dplyr\" and other functions, you won’t have the need to disect every single command. A first step is to select() variables year and name: select(storms, year, name) ## # A tibble: 11,859 × 2 ## year name ## &lt;dbl&gt; &lt;chr&gt; ## 1 1975 Amy ## 2 1975 Amy ## 3 1975 Amy ## 4 1975 Amy ## 5 1975 Amy ## 6 1975 Amy ## 7 1975 Amy ## 8 1975 Amy ## 9 1975 Amy ## 10 1975 Amy ## # … with 11,849 more rows Next, we need to group_by() year. At first glance, the previous output and the output below seem identical. But notice the tiny difference: the output below has a second line of text with some relevant information: # Groups: year [41], telling us that the values are grouped by year. group_by(select(storms, year, name), year) ## # A tibble: 11,859 × 2 ## # Groups: year [46] ## year name ## &lt;dbl&gt; &lt;chr&gt; ## 1 1975 Amy ## 2 1975 Amy ## 3 1975 Amy ## 4 1975 Amy ## 5 1975 Amy ## 6 1975 Amy ## 7 1975 Amy ## 8 1975 Amy ## 9 1975 Amy ## 10 1975 Amy ## # … with 11,849 more rows Then, we identify the distinct() values (combination of year-name): distinct(group_by(select(storms, year, name), year)) ## # A tibble: 512 × 2 ## # Groups: year [46] ## year name ## &lt;dbl&gt; &lt;chr&gt; ## 1 1975 Amy ## 2 1975 Caroline ## 3 1975 Doris ## 4 1976 Belle ## 5 1976 Gloria ## 6 1977 Anita ## 7 1977 Clara ## 8 1977 Evelyn ## 9 1978 Amelia ## 10 1978 Bess ## # … with 502 more rows For convenience purposes, let’s assign this table into its own object, which we can call storms_year_name storms_year_name &lt;- distinct(group_by(select(storms, year, name), year)) Finally, we need to count() how many storms are in each year: count(storms_year_name, year) ## # A tibble: 46 × 2 ## # Groups: year [46] ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1975 3 ## 2 1976 2 ## 3 1977 3 ## 4 1978 4 ## 5 1979 7 ## 6 1980 8 ## 7 1981 5 ## 8 1982 5 ## 9 1983 4 ## 10 1984 10 ## # … with 36 more rows All the previous commands can be assembled together with various embedded lines of code: storms_per_year &lt;- count( distinct( group_by( select(storms, year, name), year) ) ) storms_per_year ## # A tibble: 46 × 2 ## # Groups: year [46] ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1975 3 ## 2 1976 2 ## 3 1977 3 ## 4 1978 4 ## 5 1979 7 ## 6 1980 8 ## 7 1981 5 ## 8 1982 5 ## 9 1983 4 ## 10 1984 10 ## # … with 36 more rows Now that we have the counts or frequencies, we can make our next barchart. In this case, we will use the table storms_year_name as the input data for ggplot(): ggplot(data = storms_year_name) + geom_bar(aes(x = year)) By looking at the chart, there are some fairly tall bars. Although it’s hard to see exactly which years have a considerably large number of storms, eyeballing things out it seems that around 1995, 2003, 2005, and 2010 there are 20 or more storms. We can find the actual answer by using arrange(), specifying the counts to be shown in descending order—with desc(): arrange(storms_per_year, desc(n)) ## # A tibble: 46 × 2 ## # Groups: year [46] ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 2020 26 ## 2 1995 21 ## 3 2005 21 ## 4 2003 20 ## 5 2010 20 ## 6 2019 18 ## 7 2001 17 ## 8 2012 17 ## 9 2000 16 ## 10 2007 16 ## # … with 36 more rows As you can tell, in the 41-year period from 1975 to 2015, there are two years, 1995 and 2005, with a maximum number of storms equal to 21. 11.2 Your Turn Use \"dplyr\" functions/commands to create a table (e.g. tibble) storm_records_per_year containing three columns: 1) name of storm, 2) year of storm, and 3) count for number of recorded valued (of the corresponding storm). Use \"dplyr\" functions/commands to create a table (e.g. tibble) storms_categ5 containing the name and year of those storms of category 5. Use \"dplyr\" functions/commands to display a table showing the status, avg_pressure (average pressure), and avg_wind (average wind speed), for each type of storm category. This table should contain four columns: 1) category, 2) status, 3) avg_pressure, and 4) avg_wind. Use \"dplyr\" functions/commands to create a table (e.g. tibble) max_wind_per_storm containing three columns: 1) year of storm, 2) name of storm, and 3) max_wind maximum wind speed record (for that storm). Use \"dplyr\" functions/commands to create a table (e.g. tibble) max_wind_per_year containing three columns: 1) year of storm, 2) name of storm, and 3) wind maximum wind speed record (for that year). Arrange rows by wind speed in decreasing order. "],["counting-tropical-systems.html", "12 Counting Tropical Systems", " 12 Counting Tropical Systems In chapter 4 we quickly explored the values in column year, discovering the 45-year period of recorded data from 1975 to 2020. We can take a further step and ask: How many storms are there in each year? To answer this question, we need to do some data manipulation. My general recommendation when working with \"dplyr\"’s functions, especially when you are learning about them, is to do computations step by step, deciding which columns you need to use, which rows to consider, which functions to call, and so on. Attempt Number 1 To find the number of storms per year, think about the columns that you need to select. Also think about the operations that seem to be required to get such count. You obviously need to select year; and you need to count(). With this initial setting, you could assemble the following pipeline of commands: # first attempt storms %&gt;% select(year) %&gt;% count() ## # A tibble: 1 × 1 ## n ## &lt;int&gt; ## 1 11859 Okay. This count is not what we are looking for. But before trying other ideas, spend some time reflecting on what the preceding command is doing. Attempt Number 2 Perhaps we could add a group_by(year) operation before invoking count(): # second attempt storms %&gt;% select(year) %&gt;% group_by(year) %&gt;% count() ## # A tibble: 46 × 2 ## # Groups: year [46] ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1975 86 ## 2 1976 52 ## 3 1977 53 ## 4 1978 54 ## 5 1979 301 ## 6 1980 161 ## 7 1981 164 ## 8 1982 105 ## 9 1983 79 ## 10 1984 236 ## # … with 36 more rows This result looks more interesting. The returned output is a table with two columns: year and n. But after careful inspection, you should notice something awkward. While the first column makes complete sense, the second column n does not seem to be very helpful. Are there really 86 tropical systems in 1975? Are there 52 systems in 1976? And so on, and so forth? Of course not; 1975 did not have 86 systems. The numeric values under column n simply refer to the number of entries (i.e. rows) associated to each year. You may not know this, but the previous table of counts can be obtained using a more compact command without the need to use select() and group_by(); you can just simply invoke count(year): # same output of preceding command, only using count() storms %&gt;% count(year) ## # A tibble: 46 × 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1975 86 ## 2 1976 52 ## 3 1977 53 ## 4 1978 54 ## 5 1979 301 ## 6 1980 161 ## 7 1981 164 ## 8 1982 105 ## 9 1983 79 ## 10 1984 236 ## # … with 36 more rows Attempt Number 3 What if instead of counting year we count based on column name? For example: # third attempt storms %&gt;% count(name) ## # A tibble: 214 × 2 ## name n ## &lt;chr&gt; &lt;int&gt; ## 1 AL011993 8 ## 2 AL012000 4 ## 3 AL021992 5 ## 4 AL021994 6 ## 5 AL021999 4 ## 6 AL022000 12 ## 7 AL022001 5 ## 8 AL022003 4 ## 9 AL022006 5 ## 10 AL031987 32 ## # … with 204 more rows Mmm. Again, not the count that we are looking for. On a side note, observe the values displayed in the first rows of the returned table: e.g. AL011993, AL012000. These alphanumeric names correspond to names of tropical depressions that never reached tropical storm status. In other words, those system were not strong enough to be given a name, e.g. Amy, Caroline, Doris, etc. Attempt Number 4 So far we’ve tried—unsuccessfully—counting based on column year alone, and also on column name alone. None of these columns, in and of itself, is enough because for any given storm or any given year we have multiple entries with duplicated values. Again, the following suggestion may not seem obvious, but you can also try counting by taking into account both year and name # fourth attempt storms %&gt;% count(year, name) ## # A tibble: 512 × 3 ## year name n ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; ## 1 1975 Amy 30 ## 2 1975 Caroline 33 ## 3 1975 Doris 23 ## 4 1976 Belle 18 ## 5 1976 Gloria 34 ## 6 1977 Anita 20 ## 7 1977 Clara 24 ## 8 1977 Evelyn 9 ## 9 1978 Amelia 6 ## 10 1978 Bess 13 ## # … with 502 more rows Compared to the previous attempts, this output looks more promising. Finally, we can see that there were three (named) storms in 1975, two in 1976, three more in 1977, etc. However, we still don’t have those specific counts: 3, 2, 3, etc. But at least we are making some progress in what it seems to be the right direction. Attempt Number 5 Why not taking the preceding command, and adding an extra count() but only considering year? # fifth attempt storms %&gt;% count(year, name) %&gt;% count(year) ## # A tibble: 46 × 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1975 3 ## 2 1976 2 ## 3 1977 3 ## 4 1978 4 ## 5 1979 7 ## 6 1980 8 ## 7 1981 5 ## 8 1982 5 ## 9 1983 4 ## 10 1984 10 ## # … with 36 more rows Voila! Now we are talking. This table contains precisely the counts that we are looking for: number of systems in each year. For convenience purposes, let’s assign this table into its own object, which we can call system_counts_per_year, or some other meaningful name that you might prefer to use: system_counts_per_year &lt;- storms %&gt;% count(year, name) %&gt;% count(year) system_counts_per_year ## # A tibble: 46 × 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1975 3 ## 2 1976 2 ## 3 1977 3 ## 4 1978 4 ## 5 1979 7 ## 6 1980 8 ## 7 1981 5 ## 8 1982 5 ## 9 1983 4 ## 10 1984 10 ## # … with 36 more rows Now that we have the counts or frequencies, it would be nice to visualize them with a barchart, like the following one: Let’s discuss how to obtain this kind of graphic in the next chapter. "],["visualizing-number-of-systems.html", "13 Visualizing Number of Systems 13.1 Barcharts 13.2 Customizing a Barchart", " 13 Visualizing Number of Systems We ended the preceding chapter with the following command that allows us to get the number of tropical systems in each year from 1975 to 2020: system_counts_per_year &lt;- storms %&gt;% count(year, name) %&gt;% count(year) system_counts_per_year ## # A tibble: 46 × 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1975 3 ## 2 1976 2 ## 3 1977 3 ## 4 1978 4 ## 5 1979 7 ## 6 1980 8 ## 7 1981 5 ## 8 1982 5 ## 9 1983 4 ## 10 1984 10 ## # … with 36 more rows Let’s now talk about how to use \"ggplot2\" functions to obtain a data visualization of the above frequencies. 13.1 Barcharts In chapter 4, we created a basic barchart of all year values. To be more precise, we obtained a barchart based on all the entries for each given year by invoking the command shown below: # from chapter 4: barchart of year values ggplot(data = storms) + geom_bar(aes(x = year)) As you can tell, the geometric object (geom) function that is used in this case is geom_bar(). This function, by default, does its own computation—via stat_count()—to get the counts or frequencies. 13.1.1 Barchart with geom_bar() It feels very tempting and natural to use the same \"ggplot2\" functions of the preceding command in order to create a bar-plot for the number of tropical systems in each year. After all, this is exactly the type of chart we want to produce. So why not using geom_bar()? Let’s try this out. # doesn&#39;t work as expected ggplot(data = system_counts_per_year) + geom_bar(aes(x = year)) Ooops! What is going on with this graphic? Why do all bars have the same height? And why the y-axis has a count scale from 0 to 1? This doesn’t make any sense. Well, the explanation has to do with the technical fact that, as we just said, by default geom_bar() does its own tally of year values. Because the table system_counts_per_year already has the frequencies in column n, we need to tell geom_bar() to not count anything. This is done by adding a y argument to the aesthetic mapping function aes(), and also by setting the argument stat = \"identity\" # this works ggplot(data = system_counts_per_year) + geom_bar(aes(x = year, y = n), stat = &quot;identity&quot;) 13.1.2 Barchart with geom_col() Often, there is more than one way to obtain a given output or a given graphic. Interestingly, in this case we can also get a barchart with the geom_col() function. This is a sibling function of geom_bar(stat = \"identity\"), designed to be used for tables of frequencies, like system_counts_per_year: # another way to get a barchart, given a table of frequencies ggplot(data = system_counts_per_year) + geom_col(aes(x = year, y = n)) Looking at the chart, there are some fairly tall bars. Although it’s hard to see exactly which years have a considerably large number of tropical systems, eyeballing things out it seems that around 1995, 2005, and 2020 there are 20 or more storms. We can find the actual answer by using arrange(), specifying the counts to be shown in descending order—with desc(): arrange(system_counts_per_year, desc(n)) ## # A tibble: 46 × 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 2020 26 ## 2 1995 21 ## 3 2005 21 ## 4 2003 20 ## 5 2010 20 ## 6 2019 18 ## 7 2001 17 ## 8 2012 17 ## 9 2000 16 ## 10 2007 16 ## # … with 36 more rows As you can tell, in the 45-year period from 1975 to 2020, the top three years by number of systems correspond to 2020, 1995 and 2005. 13.2 Customizing a Barchart For illustration purposes, let’s further customize the bar plot by adding a title, a more descriptive y-axis label, a simple background theme, and things like that. For instance, the function labs() can be used to customize a title, a subtitle, as well as axis labels. Likewise, the theme_minimal() function provides a simplified background theme that, in my opinion, gives a neat look to the graphic. ggplot(data = system_counts_per_year) + geom_col(aes(x = year, y = n)) + labs(title = &quot;Number of tropical systems per year&quot;, subtitle = &quot;(1975-2020)&quot;, y = &quot;count&quot;) + theme_minimal() 13.2.1 Global versus Local Aesthetic Mappings An equivalent way to get the above plot can be obtained if we move the mapping aes() inside ggplot(). ggplot(data = system_counts_per_year, aes(x = year, y = n)) + geom_col() + labs(title = &quot;Number of tropical systems per year&quot;, subtitle = &quot;(1975-2020)&quot;, y = &quot;count&quot;) + theme_minimal() Relocating the mapping command aes() may seem a bit whimsical. What difference it makes if we place aes() inside ggplot() versus if we place it inside geom_col()? It turns out that there is an important difference. Any mapping done at the level of ggplot() is considered to be a global mapping in the sense that this cascades down to any additional layer, such as geom_col(). In contrast, any mapping done at the level of a geom_...() function or any other layer function acts as a local mapping, only affecting that particular type of geometric object. To further illustrate the effect of aes(), let’s add a smoother to highlight the increasing trend that the number of storms have experienced in the visualized period of time. To do this, we add a new layer using stat_smooth() with arguments method = \"loess\" and se = FALSE ggplot(data = system_counts_per_year, aes(x = year, y = n)) + geom_col(fill = &quot;gray50&quot;) + stat_smooth(method = &quot;loess&quot;, se = FALSE) + labs(title = &quot;Number of tropical systems per year&quot;, subtitle = &quot;(1975-2020)&quot;, y = &quot;count&quot;) + theme_minimal() The argument method = \"loess\" uses a non-linear smoother; in turn, se = FALSE prevents the standard error ribbon from being plotted. Observe also that the fill color of the bars has been changed to a less darker gray in order to better distinguish the blue smoother. Compare the above command with the following one in which the aesthetic mapping aes(x = year, y = n) is done at the geom_col() level: # error ggplot(data = system_counts_per_year) + geom_col(aes(x = year, y = n), fill = &quot;gray50&quot;) + stat_smooth(method = &quot;loess&quot;, se = FALSE) + labs(title = &quot;Number of tropical systems per year&quot;, subtitle = &quot;(1975-2020)&quot;, y = &quot;count&quot;) + theme_minimal() ## `geom_smooth()` using formula &#39;y ~ x&#39; ## Error in `check_required_aesthetics()`: ## ! stat_smooth requires the following missing aesthetics: x and y Oh no! Houston, we have a problem. Every time you get an error message, do the following two things: First, don’t panic, Second, read the error message. As you can tell, the error indicates that stat_smooth() requires missing aesthetics: x and y. You may argue that those statistics, x and y, are already specified in aes(), inside geom_col(). And you are correct. But this is precisely the issue. Those aesthetics only work for geom_col(), not for stat_smooth(). One option to fix this problem is by including the same mapping into stat_smooth() # fixing the error ggplot(data = system_counts_per_year) + geom_col(aes(x = year, y = n), fill = &quot;gray50&quot;) + stat_smooth(aes(x = year, y = n), method = &quot;loess&quot;, se = FALSE) + labs(title = &quot;Number of tropical systems per year&quot;, subtitle = &quot;(1975-2020)&quot;, y = &quot;count&quot;) + theme_minimal() While this fixes the problem, we’ve introduced unnecessary duplication into our code. Why? Because the mapping command aes(x = year, y = n) appears in two different places. A better option is to simply use one call to aes() at the top ggplot()level. In this form the mapping propagates to both geom_col() and stat_smooth() # getting rid of the duplicated piece of code ggplot(data = system_counts_per_year, aes(x = year, y = n)) + geom_col(fill = &quot;gray50&quot;) + stat_smooth(method = &quot;loess&quot;, se = FALSE) + labs(title = &quot;Number of tropical systems per year&quot;, subtitle = &quot;(1975-2020)&quot;, y = &quot;count&quot;) + theme_minimal() "],["counting-more-systems.html", "14 Counting More Systems 14.1 Counting Kinds of Storms", " 14 Counting More Systems In the two previous chapters you learned how to count the number of tropical systems in each year, and how to graph a barchart of such counts. In this chapter, we continue discussing how to obtain more counts. Specifically, we describe how to get the frequencies of say tropical depressions, or tropical storms, or hurricanes, or major hurricanes. 14.1 Counting Kinds of Storms Recall that tropical systems are classified into different categories depending on their wind speed. This classification is based on the famous Saffir-Simpson wind scale, given in the following table. Table: Saffir-Simpson scale Category Scale knots (kn) mph Tropical Depression -1 \\(&lt;=\\) 33 \\(&lt;=\\) 38 Tropical Storm 0 34 - 63 39 - 73 Hurricane category 1 1 64 - 82 74 - 95 Hurricane category 2 2 83 - 95 96 - 110 Hurricane category 3 3 96 - 112 111 - 129 Hurricane category 4 4 113 - 136 130 - 156 Hurricane category 5 5 \\(&gt;=\\) 137 \\(&gt;=\\) 157 Hurricanes of categories 3, 4, and 5 are considered to be major hurricanes. 14.1.1 Counting Tropical Depressions We may start by getting the count of tropical depressions per year. Knowing that tropical depressions have winds no greater than 33 knots, we can filter() column wind for this numeric value. # trying to count tropical depressions per year depression_counts_per_year = storms %&gt;% filter(wind &lt;= 33) %&gt;% count(year, name) %&gt;% count(year) # inspect a few rows head(depression_counts_per_year) ## # A tibble: 6 × 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1975 2 ## 2 1976 2 ## 3 1977 3 ## 4 1978 4 ## 5 1979 7 ## 6 1980 6 According to this output, it seems that there were 2 tropical depressions in 1975, 2 in 1976, 3 in 1977, etc. What about the number of tropical storms? Well, to obtain this count we should filter wind values between 34 and 63 knots, and then compute the count(): # trying to count tropical storms per year storm_counts_per_year = storms %&gt;% filter(wind &gt;= 34 &amp; wind &lt; 64) %&gt;% count(year, name) %&gt;% count(year) # inspect a few rows head(storm_counts_per_year) ## # A tibble: 6 × 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1975 3 ## 2 1976 2 ## 3 1977 3 ## 4 1978 4 ## 5 1979 7 ## 6 1980 7 Based on this output, it seems that there were 3 tropical storms in 1975, 2 in 1976, 3 in 1977, etc. But wait … We know, from the preceding chapter, that the counts of systems per year are: system_counts_per_year &lt;- storms %&gt;% count(year, name) %&gt;% count(year) head(system_counts_per_year) ## # A tibble: 6 × 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1975 3 ## 2 1976 2 ## 3 1977 3 ## 4 1978 4 ## 5 1979 7 ## 6 1980 8 How come is it that in 1975 there were two tropical depressions, and also two tropical storms, but a total of three systems? Likewise, how is it that in 1976 there were also two tropical depressions, and two tropical storms, but a total of only two systems? Okay, okay. You may know the answer to this apparent conundrum. The explanation for these seemingly contradictory results has to do with the life cycle of tropical systems. Technically speaking, they all start as baby storms or disturbances that can get bigger, eventually reaching tropical depression status, and under the right weather conditions, they can continue to grow reaching tropical storm category, or hurricane of category 1, or other bigger categories. I know that the above outputs and the interpretations I’m providing for them may seem a bit silly to (some of) you. Yes, I’m doing it on purpose: to walk you through the type of exploration, sanity checks, and questions that you should be asking yourself along the way when analyzing data. This is especially vital when you are working with a data set from some topic or field in which you don’t have much experience with. 14.1.2 Counts Based on Maximum Wind Speed A more adequate approach for identifying tropical depressions consists of first obtaining the maximum wind speed of each system, and then filtering for values of 33 knots or less. # identifying tropical depressions depressions = storms %&gt;% group_by(year, name) %&gt;% summarise(wind_max = max(wind), .groups = &quot;drop&quot;) %&gt;% filter(wind_max &lt;= 33) slice_head(depressions, n = 10) ## # A tibble: 10 × 3 ## year name wind_max ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; ## 1 1991 AL041991 30 ## 2 1991 AL101991 25 ## 3 1992 AL021992 30 ## 4 1992 AL031992 30 ## 5 1992 AL081992 30 ## 6 1993 AL011993 30 ## 7 1993 AL101993 30 ## 8 1994 AL021994 30 ## 9 1994 AL051994 30 ## 10 1994 AL081994 30 Having obtained the data that exclusively contains tropical depressions, we can then count their number in each year: # counting tropical depressions per year depression_counts_per_year = depressions %&gt;% count(year) slice_head(depression_counts_per_year, n = 10) ## # A tibble: 10 × 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1991 2 ## 2 1992 3 ## 3 1993 2 ## 4 1994 5 ## 5 1995 2 ## 6 1997 1 ## 7 1999 4 ## 8 2000 4 ## 9 2001 2 ## 10 2002 2 14.1.3 Counting Tropical Storms Tropical storms are tropical systems with wind speeds between 39 mph and 73 mph or equivalently, between 34 and 63 knots. With this information, we proceed in the same way as in the above subsection: first we identify the set that exclusively contains tropical storms, and then we count them by year. # identifying tropical storms trop_storms = storms %&gt;% group_by(year, name) %&gt;% summarise(wind_max = max(wind), .groups = &quot;drop&quot;) %&gt;% filter(wind_max &gt;= 34 &amp; wind_max &lt; 64) slice_head(trop_storms, n = 10) ## # A tibble: 10 × 3 ## year name wind_max ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; ## 1 1975 Amy 60 ## 2 1978 Amelia 45 ## 3 1978 Bess 45 ## 4 1978 Juliet 45 ## 5 1979 Ana 50 ## 6 1979 Claudette 45 ## 7 1980 Danielle 50 ## 8 1980 Hermine 60 ## 9 1982 Beryl 60 ## 10 1982 Chris 55 # counting tropical storms per year storm_counts_per_year = trop_storms %&gt;% count(year) slice_head(storm_counts_per_year, n = 10) ## # A tibble: 10 × 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 1975 1 ## 2 1978 3 ## 3 1979 2 ## 4 1980 2 ## 5 1982 3 ## 6 1983 1 ## 7 1984 5 ## 8 1985 4 ## 9 1986 2 ## 10 1987 1 So far, so good. Things seem to make sense, and we are making nice progress in our data exploration journey. But before moving on with other counts, let’s do a quick sanity check (just in case). For example, we could take into consideration the column category. This column contains numeric codes for the different types of categories based on the Saffir-Simpson wind scale. To be more precise: in addition to wind_max, let’s also include the maximum category value when identifying the set of tropical storms. If everything is correct, all the entries should have category value of 0 which is the numeric code for tropical storms. # identifying tropical storms trop_storms = storms %&gt;% group_by(year, name) %&gt;% summarise( wind_max = max(wind), categ_max = max(category), .groups = &quot;drop&quot;) %&gt;% filter(wind_max &gt;= 34 &amp; wind_max &lt; 64) slice_head(trop_storms, n = 10) ## # A tibble: 10 × 4 ## year name wind_max categ_max ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;ord&gt; ## 1 1975 Amy 60 0 ## 2 1978 Amelia 45 0 ## 3 1978 Bess 45 0 ## 4 1978 Juliet 45 0 ## 5 1979 Ana 50 0 ## 6 1979 Claudette 45 0 ## 7 1980 Danielle 50 0 ## 8 1980 Hermine 60 0 ## 9 1982 Beryl 60 0 ## 10 1982 Chris 55 0 This output only displays the first ten rows, but you are welcome to inspect the values in column categ_max to confirm that all of them are 0. Did you observe anything special? Was there anything that caught your attention? If your answer is “No”, then go back to carefully inspect the content of trop_storms. If your answer is “Yes”, because you noticed some weird storm names such as AL031987 or AL061988, then let me say to you: “good job!” Indeed, there seem to be a few tropical storms (category 0) that don’t have a proper name. In theory, once a tropical system reaches tropical storm status, it receives a non-alphanumeric name such as Amy or Amelia or Bess. To detect all the entries in trop_storms that don’t have a proper name you can use the following command: # unnamed storms trop_storms %&gt;% filter(str_starts(name, pattern = &quot;A(l|L)\\\\d+&quot;)) ## # A tibble: 4 × 4 ## year name wind_max categ_max ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;ord&gt; ## 1 1987 AL031987 40 0 ## 2 1988 AL061988 50 0 ## 3 2006 AL022006 45 0 ## 4 2011 Al202011 40 0 As you can tell, this command is a filtering operation. However, the code inside filter() is somewhat advanced. It uses the str_starts() function to match for those names that start with either \"AL\" or \"Al\" and are followed by several digits. To be honest, I’m not sure why we have these mismatched values. It could be that the category values for these systems are incorrect. Or it could be the opposite: the category is okay, but the problem is with the name values. "],["counting-all-types-of-systems.html", "15 Counting All Types of Systems 15.1 Handling Various Conditions", " 15 Counting All Types of Systems So far we’ve found a satisfying way to count the number of tropical depressions as well as the number of tropical storms. We could adapt the recent commands to get a table with counts of hurricanes of category 1, another table for hurricanes of category 2, and so on and so for. Interestingly, we can also identify the maximum category for each type of system, all at once. All we have to do is remove the filter() command, as follows: system_status = storms %&gt;% group_by(year, name) %&gt;% summarise( wind_max = max(wind), categ_max = max(category), .groups = &quot;drop&quot;) slice_head(system_status, n = 10) ## # A tibble: 10 × 4 ## year name wind_max categ_max ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;ord&gt; ## 1 1975 Amy 60 0 ## 2 1975 Caroline 100 3 ## 3 1975 Doris 95 2 ## 4 1976 Belle 105 3 ## 5 1976 Gloria 90 2 ## 6 1977 Anita 150 5 ## 7 1977 Clara 65 1 ## 8 1977 Evelyn 70 1 ## 9 1978 Amelia 45 0 ## 10 1978 Bess 45 0 15.1 Handling Various Conditions We can take a further step and add a column that displays the category status in text form. That is, for categ_max == -1 have an associated value of \"depression\"; for categ_max == 0 have an associated value of \"storm\"; for categ_max == 1 have an associated value of \"hurr1\", etc. How can you accomplish this? One nice option is with the case_when() function. Let’s take a look at the command that gets the job done, and then we discuss it. # adding a wind category status in text format system_status = storms %&gt;% group_by(year, name) %&gt;% summarise( wind_max = max(wind), wind_scale = max(category), .groups = &quot;drop&quot;) %&gt;% mutate(wind_categ = case_when( wind_scale == 5 ~ &quot;hurr5&quot;, wind_scale == 4 ~ &quot;hurr4&quot;, wind_scale == 3 ~ &quot;hurr3&quot;, wind_scale == 2 ~ &quot;hurr2&quot;, wind_scale == 1 ~ &quot;hurr1&quot;, wind_scale == 0 ~ &quot;storm&quot;, wind_scale == -1 ~ &quot;depression&quot;, )) slice_head(system_status, n = 10) ## # A tibble: 10 × 5 ## year name wind_max wind_scale wind_categ ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;ord&gt; &lt;chr&gt; ## 1 1975 Amy 60 0 storm ## 2 1975 Caroline 100 3 hurr3 ## 3 1975 Doris 95 2 hurr2 ## 4 1976 Belle 105 3 hurr3 ## 5 1976 Gloria 90 2 hurr2 ## 6 1977 Anita 150 5 hurr5 ## 7 1977 Clara 65 1 hurr1 ## 8 1977 Evelyn 70 1 hurr1 ## 9 1978 Amelia 45 0 storm ## 10 1978 Bess 45 0 storm To describe how case_when() works, let’s pay attention to the part of the code that involves this command: case_when( wind_scale == 5 ~ &quot;hurr5&quot;, wind_scale == 4 ~ &quot;hurr4&quot;, wind_scale == 3 ~ &quot;hurr3&quot;, wind_scale == 2 ~ &quot;hurr2&quot;, wind_scale == 1 ~ &quot;hurr1&quot;, wind_scale == 0 ~ &quot;storm&quot;, wind_scale == -1 ~ &quot;depression&quot;, ) As you can tell, the input to case_when() consists of multiple conditions based on the variable wind_scale. The first condition is: wind_scale == 5 ~ &quot;hurr5&quot; This means that the value \"hurr5\" will be associated to all the wind_scale values equal to 5. Basically, this indicates a hurricane of category 5. The next condition is: wind_scale == 4 ~ &quot;hurr4&quot; which means that \"hurr4\" will be associated to all the wind_scale values equal to 4 related to hurricanes of category 4. And so on, and so forth. Observe also the use of the tilde ~ to indicate the output for each text value. system_status %&gt;% count(year, wind_scale) %&gt;% ggplot() + geom_col(aes(x = year, y = n, fill = wind_scale)) + labs(title = &quot;Number of Storms per Year, and Category&quot;, y = &quot;Count&quot;) + theme_minimal() This barchart allows us to see how different storm categories are distributed over time. As we know from the graphics obtained in chapter 13, the number of systems shows an increasing trend. Despite the eye catching color palette, and the clear increasing pattern, it is hard to tell whether all the storm categories exhibit the growing trend. An alternative visual display is to use facets so that we separate each category in its own frame (see below). system_status %&gt;% count(year, wind_scale) %&gt;% ggplot() + geom_col(aes(x = year, y = n, fill = wind_scale)) + facet_wrap(~ wind_scale) + labs(title = &quot;Number of Storms Over Time, and Category&quot;, subtitle = &quot;Tropical storms have increased in the last 4 decades&quot;, y = &quot;Count&quot;) + theme_minimal() + theme(panel.grid.minor = element_blank()) In this plot we can easily see that the main type of systems that have been constantly increasing every decade are tropical storms (category 0). This pattern was not so evident in the preceding graphic that does not have facets. If you look at hurricanes of category 3, their number seems to remain stable between 0 and 2 almost every year. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
